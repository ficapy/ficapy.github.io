<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>邹雷</title>
  <subtitle>刨过的坑,自己慢慢来填</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zoulei.net/"/>
  <updated>2017-05-31T04:14:23.000Z</updated>
  <id>https://www.zoulei.net/</id>
  
  <author>
    <name>ficapy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解metaclass</title>
    <link href="https://www.zoulei.net/2017/05/31/python_metaclass/"/>
    <id>https://www.zoulei.net/2017/05/31/python_metaclass/</id>
    <published>2017-05-31T04:14:23.000Z</published>
    <updated>2017-05-31T04:14:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>metaclass一直被归类为比较高深的内容，写代码也很少会使用到metaclass。然而如果你看某些项目的源代码，还是会被绕到metaclass里面去。花一些时间理解下metaclass很有用的，因为它真的能把一条线串起来，环环相扣，所以有扎实的基础是掌握metaclass的前提，本文代码基于python3.5</p>
<a id="more"></a>
<p>你只需要理解以下2点</p>
<ol>
<li>metaclass和<code>__new__</code>、<code>__init__</code>并没有非常非常深的关系</li>
<li>type(name, bases, dict)生成了一个object类，了解三个参数分别指代了什么</li>
</ol>
<p>了解python中有这样一条关系链type-&gt;object-&gt;instance,通常我们写类默认会继承自object。从关系链就能知道type能够生成object。代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        attrs.pop(<span class="string">'e'</span>)</span><br><span class="line">        print(<span class="string">'1'</span>, cls, name, bases, attrs)</span><br><span class="line">        cls.a = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def __call__(self, *args, **kwargs):</span></span><br><span class="line">    <span class="comment">#     print('3')</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, attrs)</span>:</span></span><br><span class="line">        self.b = <span class="number">2</span></span><br><span class="line">        print(<span class="string">'2'</span>, self, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(metaclass=A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'4'</span>, args, kwargs)</span><br><span class="line">        cls.c = <span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">e</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'5'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d)</span>:</span></span><br><span class="line">        self.d = d</span><br><span class="line">        print(<span class="string">'6'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b = B(<span class="number">6</span>)</span><br><span class="line">print(hasattr(b, <span class="string">'a'</span>))</span><br><span class="line">print(b.b)</span><br><span class="line">print(b.c)</span><br><span class="line">print(b.d)</span><br><span class="line">print(hasattr(b, <span class="string">'e'</span>))</span><br></pre></td></tr></table></figure>
<p>可以尝试注释掉B(12)，A依旧会被打印，观察args和kwargs的输出。对比A和B的不同，你会发现metaclass的用处，<strong>使用metaclass的时候，B的所有属性会被当做参数传递给A</strong>，那么我们能够将这些传过来的参数预处理然后挂在到类的属性上面返回。以供后续B使用。目前在我遇到的web开发中体现的最常见的就是ORM和表单验证。</p>
<p>我们知道<code>__new__</code>创建一个对象。<code>__init__</code>对创建后的对象进行赋值等初始化操作。他们的传参args和kwargs是没有区别的。但是在<code>__new__</code>阶段，能够对attrs进行修改从而hook对象的创建流程，除此之外感觉只能用new不能用init的场景是很少的。目前看到的例子记得的可能只有用new实现单例。对于内置不可变对象比如int用new变更初始化逻辑</p>
<p>最后例举一个ORM的例子(见参考)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, column_type)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.column_type = column_type</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super(StringField, self).__init__(name, <span class="string">'vachar(100)'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelMetaclass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name != <span class="string">'Model'</span>:</span><br><span class="line">            mappings = &#123;k: v.name <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items() <span class="keyword">if</span> isinstance(v, Field)&#125;</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</span><br><span class="line">                attrs.pop(k)</span><br><span class="line">            attrs[<span class="string">'__mappings__'</span>] = mappings</span><br><span class="line">            attrs[<span class="string">'__table__'</span>] = name</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(dict, metaclass=ModelMetaclass)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super().__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r"'Model' object has no attribute &#123;key&#125;"</span>.format(key=key))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self)</span>:</span></span><br><span class="line">        fields, params, args = [], [], []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__mappings__.items():</span><br><span class="line">            fields.append(v)</span><br><span class="line">            params.append(<span class="string">'?'</span>)</span><br><span class="line">            args.append(getattr(self, k, <span class="keyword">None</span>))</span><br><span class="line">        sql = <span class="string">'insert into &#123;table_name&#125; (&#123;fields&#125;) values (&#123;values&#125;)'</span>.format(table_name=self.__table__,</span><br><span class="line">                                                                             fields=<span class="string">','</span>.join(fields),</span><br><span class="line">                                                                             values=<span class="string">','</span>.join(params))</span><br><span class="line">        print(<span class="string">'SQL: &#123;sql&#125;'</span>.format(sql=sql))</span><br><span class="line">        print(<span class="string">'ARGS: &#123;args&#125;'</span>.format(args=args))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span><span class="params">(Model)</span>:</span></span><br><span class="line">    user_name = StringField(<span class="string">'username'</span>)</span><br><span class="line">    email = StringField(<span class="string">'email'</span>)</span><br><span class="line">    password = StringField(<span class="string">'password'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    user = UserModel(user_id=<span class="number">123</span>, user_name=<span class="string">'hhh'</span>, email=<span class="string">'a@a.a'</span>, password=<span class="string">'asdfa'</span>, x=<span class="string">'y'</span>)</span><br><span class="line">    user.save()</span><br></pre></td></tr></table></figure>    </p>
<p>下篇会分析metaclass在WTForms中的应用</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">Understanding Python metaclasses 更详细的介绍</a><br><a href="http://www.jianshu.com/p/9dfa40bf2a62">python实现ORM</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;metaclass一直被归类为比较高深的内容，写代码也很少会使用到metaclass。然而如果你看某些项目的源代码，还是会被绕到metaclass里面去。花一些时间理解下metaclass很有用的，因为它真的能把一条线串起来，环环相扣，所以有扎实的基础是掌握metaclass的前提，本文代码基于python3.5&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>ssh端口映射</title>
    <link href="https://www.zoulei.net/2017/05/18/ssh-port-forward/"/>
    <id>https://www.zoulei.net/2017/05/18/ssh-port-forward/</id>
    <published>2017-05-18T01:34:34.000Z</published>
    <updated>2017-03-12T04:34:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发中经常会需要用到端口映射这种事情。以前觉得好容易混淆。其实用习惯了就会发现如此简单┑(￣Д ￣)┍，下面联系到我日常使用到的一些ssh映射实例讲解一下</p>
<a id="more"></a>
<ol>
<li><p>-D参数，提供一个socket5级别的代理。</p>
<p> 这个在很多年以前翻墙的时候还是很好用的。不过都已经成为了历史。有代理使用经验的开发者都能很快理解这个玩意</p>
</li>
<li><p>-L(local forward)本地转发</p>
<p> 比如你现在需要连接到正式环境的数据库,那么你不需要先ssh到正式环境再输入数据库命令。我的做法是选择用图形界面查看数据库。命令是这样的 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L  6789:192.168.10.10:5432 prod</span><br></pre></td></tr></table></figure>
<p> 含义就是将本地6789端口接受到的请求转发到生产环境prod上面的192.168.10.10:5432，这样本地GUI数据库管理程序就能够直接连接本地6789端口显示线上数据了。可以看出它的作用就是将本地端口的请求转发的服务器上面</p>
</li>
<li><p>-R(Remote forward)远程转发</p>
<p> 这个就是和本地转发相反。在连接的服务器上打开一个端口，映射到自己的端口。此时数据流是服务器端口接收到的数据传到了本地。比如你需要一个公网ip(显然我们的办公环境都是没有公网ip的)来调试你的web应用，比如你本地写了个web程序监听8989端口，你远程服务器上有公网ip。你需要把web程序临时分享到公网给别人尝试使用。执行以下命令</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R 4321:127.0.0.1:8989 prod</span><br></pre></td></tr></table></figure>
<p> 这样别人访问prod_ip:4321就会映射到你本地的8989端口上。</p>
</li>
<li><p>助记</p>
<p> 刚开始可能觉得端口比较容易混淆。只需要记住xx:xx，前面是入口，后面是出口。本地转发的时候数据是从本地发到远程。所以6789是本地端口。远程转发的时候数据是从远程发到本地。所以8989是本地端口</p>
</li>
<li><p>辅助参数及工具</p>
<p> 假如你只需要端口映射不需要进入终端执行命令。可以增加-Nf参数，-N为不进入交互式终端。f为后台执行。假如你需要长期使用，那就使用autossh，和ssh一个套路。就不举例了</p>
</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>其实本地转发和远程转发已经形成了一个双向的数据流动。这样我们就能够实现一些看起来很高级的功能。比如访问内网机器(没有公网ip，不能够被直接访问到)。只要内网机器能够使用ssh访问到外部机器，而这台外部机器我们能够进行访问。那么此时就是搭配本地转发和远程转发的时候了。(注意，如果外部机器能够和内部机器双向访问那么会更简单)</p>
<p>思路就是使用内网机器访问外部机器，使用远程端口映射，将本机的22端口映射到外部机器的任一端口上。之后在外部机器就能够使用ssh localhost -p xx访问到内网机器了。然而这需要我们先登录到外部机器再使用localhost登陆到内网。此时我们可以更简单的使用~/.ssh/config配置文件完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host demo&#10;    user    ficapy&#10;    HostName    localhost&#10;    ProxyCommand ssh prod -W %h:7890</span><br></pre></td></tr></table></figure>
<p>ssh demo后会先连接外部机器prod,再将请求转发到localhost:7890上完成对内部机器的登陆。<br>假如内部机器和外部机器可以双向访问，那么就不需要远程端口转发，只需要这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host demo&#10;    User ficapy&#10;    HostName &#20869;&#32593;&#26426;&#22120;ip&#10;    ProxyCommand ssh prod -W %h:%p</span><br></pre></td></tr></table></figure>
<h3 id="更坑爹的情况"><a href="#更坑爹的情况" class="headerlink" title="更坑爹的情况"></a>更坑爹的情况</h3><p>在严格的环境下，假如禁用了ssh协议。不允许从内部ssh到外部。只允许对外发送http、https请求。此时ssh、ngrok1.7版本、frp这种是无法使用的。推荐使用pagekite自建，亦或者使用速度暴慢的ngrok付费版</p>
<h3 id="收集的ssh配置文件（更好的连接到远端服务器）"><a href="#收集的ssh配置文件（更好的连接到远端服务器）" class="headerlink" title="收集的ssh配置文件（更好的连接到远端服务器）"></a>收集的ssh配置文件（更好的连接到远端服务器）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host&#9;   *&#10;&#9;Port          &#9;&#9; 22&#10;    User          &#9;&#9; root&#10;    IdentityFile  &#9;&#9; ~/.ssh/id_rsa&#10;    ConnectTimeout &#9;&#9;15&#10;    ConnectionAttempts &#9;3&#10;    ServerAliveInterval &#9;20&#10;    ServerAliveCountMax &#9;5&#9;&#9;&#10;    # &#22810;&#26465;&#36830;&#25509;&#20849;&#20139;&#10;    ControlMaster   &#9;auto&#10;    ControlPath     &#9;/tmp/ssh_mux_%h_%p_%r&#10;    # &#38271;&#36830;&#25509;(&#36864;&#20986;&#26381;&#21153;&#22120;&#21518;&#36830;&#25509;&#20381;&#28982;&#21487;&#37325;&#29992;)&#10;    ControlPersist  &#9;4h&#10;    # &#20943;&#23569;&#24310;&#36831;&#10;    GSSAPIAuthentication &#9;no</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中经常会需要用到端口映射这种事情。以前觉得好容易混淆。其实用习惯了就会发现如此简单┑(￣Д ￣)┍，下面联系到我日常使用到的一些ssh映射实例讲解一下&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://www.zoulei.net/categories/DevOps/"/>
    
    
  </entry>
  
  <entry>
    <title>tornado表单验证</title>
    <link href="https://www.zoulei.net/2017/05/18/tornado_wtforms/"/>
    <id>https://www.zoulei.net/2017/05/18/tornado_wtforms/</id>
    <published>2017-05-18T01:34:34.000Z</published>
    <updated>2017-03-23T12:41:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作中看到有一些不好的代码，想了个办法优化了一下，于是有了这篇博文。本文主要讲tornado的表单验证，使用的是wtforms。本文最终达到的效果是使用self.xx获取post传递过来的值。</p>
<a id="more"></a>
<p>首先是将wtforms嵌入tornado。做法可以参考<a href="https://github.com/truemped/tornadotools/blob/master/tornadotools/forms.py">https://github.com/truemped/tornadotools/blob/master/tornadotools/forms.py</a>，我的做法类似，可以看最下面的代码。这样继承一下就能够使用wtforms的表单验证了。能够使用的结果是很多人写这样的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.xx1 = self.form.xx1.data&#10;self.xx2 = self.form.xx2.data&#10;self.xx3 = self.form.xx3.data&#10;:&#10;&#16;:</span><br></pre></td></tr></table></figure>
<p>然后这样写了20行(不黑，项目里真有这样的)。写的人也确实是很认真啊！，改进的方法很简单。调用self.xx1的时候自动取值self.form.xx1.data。能做成这样的方法挺多。很多时候会导致self.xxx使用IDE无法补全。我个人认为好的代码肯定能够方便的补全和提示，毕竟这样能实打实的提升码代码的心情，试想一下你要输入20个单词，很可能一不小心就输入错误了。改进的方法就是使用<code>__getattribute__</code>,配合类继承，兼顾自动补全也不用跑去写self.form.xxx.data了</p>
<ol>
<li><code>__getattr__</code>，当属性不存在的时候会调用</li>
<li><code>__getattribute__</code>,无论属性是否存在都会被调用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import tornado.ioloop&#10;import tornado.web&#10;&#10;from wtforms import validators, fields&#10;from wtforms import Form&#10;from wtforms.fields.core import UnboundField&#10;&#10;&#10;class MultiDict(dict):&#10;    def getlist(self, key):&#10;        return self[key]&#10;&#10;    def setlist(self, key, value):&#10;        self[key] = value&#10;&#10;&#10;class BaseForm(Form):&#10;    def __init__(self, handler=None, obj=None, prefix=&#39;&#39;, **kwargs):&#10;        if handler is None:&#10;            return&#10;        formdata = MultiDict()&#10;        if handler.request.method == &#39;POST&#39;:&#10;            for name in handler.request.arguments.keys():&#10;                formdata.setlist(name, handler.get_arguments(name))&#10;        else:&#10;            for name in handler.request.query_arguments.keys():&#10;                formdata.setlist(name, handler.request.query_arguments[name])&#10;        Form.__init__(self, formdata, obj=obj, prefix=prefix, **kwargs)&#10;&#10;&#10;class LoginForm(BaseForm):&#10;    email = fields.StringField(&#10;        validators=[validators.Email(), validators.required(), validators.length(min=5, max=64)])&#10;    password = fields.PasswordField(validators=[validators.required()])&#10;&#10;&#10;class MainHandler(tornado.web.RequestHandler, LoginForm):&#10;    def __getattribute__(self, item):&#10;        ret = object.__getattribute__(self, item)&#10;        if isinstance(ret, UnboundField):&#10;            form = object.__getattribute__(self, &#39;form&#39;)&#10;            return getattr(form, item).data&#10;        return ret&#10;&#10;    def post(self):&#10;        self.form = LoginForm(self)&#10;        print(self.email)&#10;        self.write(&#34;Hello, world&#34;)&#10;&#10;&#10;def make_app():&#10;    return tornado.web.Application([&#10;        (r&#34;/&#34;, MainHandler),&#10;    ])&#10;&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    app = make_app()&#10;    app.listen(8888)&#10;    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure>
<p>完美解决问题,心情瞬间舒畅了┑(￣Д ￣)┍</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中看到有一些不好的代码，想了个办法优化了一下，于是有了这篇博文。本文主要讲tornado的表单验证，使用的是wtforms。本文最终达到的效果是使用self.xx获取post传递过来的值。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>使用acme.sh快速搭建https</title>
    <link href="https://www.zoulei.net/2017/03/05/acme.sh_quick_start/"/>
    <id>https://www.zoulei.net/2017/03/05/acme.sh_quick_start/</id>
    <published>2017-03-05T09:19:27.000Z</published>
    <updated>2017-03-05T14:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>letsencrypt刚出来的时候写了一篇它的认证签发原理。自那过后就没有真正的去实践过了。最近有部署HTTPS的需求就又考察了一番。发现acme.sh灰常好用啊~~~，来一篇水文记录下测试部署HTTPS的完整过程吧</p>
<a id="more"></a>
<p>首先有2种认证方式，生成一个指定的文件让letsencrypt访问。或者生成一个DNS记录让letsencrypt访问。第一种方式有非常大的局限性。比如你的80端口正在被使用。那么你需要先设置DNS解析，再修改下nginx的配置让网址能够被正常访问到。这就显得很麻烦了。主流的DNS服务提供商都已经提供了API接口，使用DNS的优势就是：</p>
<ol>
<li>任何电脑都能直接生成证书文件，不需要依赖本机能够被外部访问</li>
<li>不需要对nginx做任何设置</li>
</ol>
<p>以下记录下我使用一个临时的digitalocean机器从0开始部署https的步骤(假设测试url为ssl.ficapy.com,操作环境为osx)</p>
<p>我还是要安利下，临时使用digitalocean测试使用命令行工具tugboat灰常好啊</p>
<ol>
<li><p>安装tugboat用命令行快速创建机器以及测试完成后删除</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install tugboat</span><br></pre></td></tr></table></figure>
</li>
<li><p>将digitalocean的api写入让tugboat能够正常使用,并执行一些初始化设置</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tugboat authorize</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据初始化默认设置创建一个vps</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tugboat create temp</span><br></pre></td></tr></table></figure>
</li>
<li><p>ssh登陆</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tugboat ssh temp</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装acme.sh</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://get.acme.sh | sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>参照acme.sh文档将dns的api信息作为环境变量写入(记得执行source ~/.bashrc)</p>
</li>
<li><p>生成证书</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --issue --dns dns_cf -d ssl.ficapy.com --debug</span><br></pre></td></tr></table></figure>
</li>
<li><p>将证书放置到位置并设置nginx重启命令</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --installcert -d ssl.ficapy.com \&#10;           --keypath       /etc/nginx/ssl/ssl.ficapy.com.key  \&#10;           --fullchainpath /etc/nginx/ssl/ssl.ficapy.com.pem \&#10;           --reloadcmd     &#34;service nginx force-reload&#34;</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制测试续约(该操作会自动执行注册过的事件，一般就是重启nginx咯，续约key是不会变的，变的是fullchain.cer文件)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --renew-all --force</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成dhparam文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl dhparam -out /etc/nginx/ssl/dhparam.pem 2048</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用生成一个标准的nginx配置文件并放入/etc/nginx/site-enables目录，示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;&#10;    listen 443 ssl;&#10;&#10;    server_name ssl.ficapy.com;&#10;    # certs sent to the client in SERVER HELLO are concatenated in ssl_certificate&#10;    ssl_certificate /etc/nginx/ssl/ssl.ficapy.com.pem;&#10;    ssl_certificate_key /etc/nginx/ssl/ssl.ficapy.com.key;&#10;    ssl_session_timeout 1d;&#10;    ssl_session_cache shared:SSL:50m;&#10;&#10;&#10;    # Diffie-Hellman parameter for DHE ciphersuites, recommended 2048 bits&#10;    ssl_dhparam /etc/nginx/ssl/dhparam.pem;&#10;&#10;    # intermediate configuration. tweak to your needs.&#10;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;&#10;    ssl_ciphers &#39;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS&#39;;&#10;    ssl_prefer_server_ciphers on;&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后就是浏览器访问以下测试完毕啦。如果出现错误可以查看nginx的日志/var/log/error.log，肯定是哪一步出问题啦，最后就是测试完毕后删除vps啦<code>tugboat destory temp</code></p>
</li>
</ol>
<p>额外说一下其他的吧。最开始我试过阿里云dns的api，用的是子账号。结果子账号是无法包含(注意)dns的操作权限的，就总是失败。后来不用子账号，直接用原账号的api密匙就完全没问题啦~~~。另外各大云平台大多都有负载均衡器，然后可以填写https证书。这种就不太适合letsencrypt这种短期证书了。否则总上去换证书不被麻烦死。如果在这种负载均衡器上不设置https证书。那么就需要在负载均衡器每一台机器都设置上https证书，嗯想想也挺头大啊~~~，所以这种自动化方式只比较适合在一台机器上生成并维护证书</p>
<p>再额外，哪个时候写个Ansible的playbook就好哒，可能会更加方便┑(￣Д ￣)┍</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/pearkes/tugboat">github tugboat</a><br><a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/">mozilla ssl-config-generator</a><br><a href="https://ruby-china.org/topics/31983">使用 acme.sh 给 Nginx 安装 Let’ s Encrypt 提供的免费 SSL 证书</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;letsencrypt刚出来的时候写了一篇它的认证签发原理。自那过后就没有真正的去实践过了。最近有部署HTTPS的需求就又考察了一番。发现acme.sh灰常好用啊~~~，来一篇水文记录下测试部署HTTPS的完整过程吧&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://www.zoulei.net/categories/DevOps/"/>
    
    
  </entry>
  
  <entry>
    <title>使用pre-commit改进代码风格</title>
    <link href="https://www.zoulei.net/2017/03/04/pre_commit/"/>
    <id>https://www.zoulei.net/2017/03/04/pre_commit/</id>
    <published>2017-03-04T04:52:37.000Z</published>
    <updated>2017-03-04T10:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>很早就使用过autopep8来自动格式化代码，使用IDE的时候也会经常使用格式化代码功能让代码更符合规范一点。可是这都不是自动化的，或者说是强制的。为了保持团队的良好代码风格感觉每个同事在提交代码之前都自动进行格式化或者风格检查是一个不错的主意，于是找到了<a href="http://pre-commit.com/">pre-commit</a></p>
<p>原理也还是很简单的，git自身提供了一些hook功能，查看git/hooks目录下会发现有一些sample文件，这样在执行commit、push、merge的时候都是可以进行一些简单的检查等功能的。然而这个设定有一个缺点。没一个hook只能执行一个文件的内容，所以要么将各种功能放在一个文件里面，或者每个功能都放置在各自的文件里面。最后由一个文件一起执行。pre-commit就解决了我们的这个文件。将不同的任务分割成单个文件。然后只需要添加别人共享的脚本就能够很快的进行commit hook了，简要使用方法例举如下</p>
<ol>
<li><p>在项目根目录下编写配置文件(.pre-commit-config.yaml)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-   repo: git://github.com/pre-commit/pre-commit-hooks&#10;    sha: v0.7.1&#10;    hooks:&#10;    -   id: trailing-whitespace&#10;    -   id: autopep8-wrapper</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行初始化<code>pre-commit install</code>就可以了，以后每次执行commit的时候就会执行检查。配置文件的repo地址即为符合pre-commit框架的地址，id即为提供的功能~~，还是很好理解的。例如以上提供的autopep8-wrapper就可能够配置pep8规范进行一些代码风格检查，如果不符合风格就会自动格式化。pep8工具的默认配置文件是<code>~/.config/pep8</code></p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.sideci.com/2015/12/14/style-guide-of-python-and-lint-tool/">About style guide of python and linter tool. pep8, pyflakes, flake8, haking, Pyling.</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早就使用过autopep8来自动格式化代码，使用IDE的时候也会经常使用格式化代码功能让代码更符合规范一点。可是这都不是自动化的，或者说是强制的。为了保持团队的良好代码风格感觉每个同事在提交代码之前都自动进行格式化或者风格检查是一个不错的主意，于是找到了&lt;a href=&quot;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>supervisor遇到的坑</title>
    <link href="https://www.zoulei.net/2016/12/25/supervisor_may_be_sucks/"/>
    <id>https://www.zoulei.net/2016/12/25/supervisor_may_be_sucks/</id>
    <published>2016-12-25T12:01:43.000Z</published>
    <updated>2017-01-11T08:02:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>写几条自己用supervisor遇到的一些小坑</p>
<ol>
<li><a href="https://python3wos.appspot.com/">Python 3 Wall</a>的反派代表，一直不能使用python3安装</li>
<li>对中文输出支持奇差，估计是使用python2造成的，举个例子，假如你要在python2里面print输出一个unicode中文字符。我试了各种办法，均无解(和supervisor使用子进程运行程序的策略有关),好在使用logging模块输出中文居然没啥问题-_-，正式运行环境也是全部使用logging代替print</li>
<li>即使用python3，输出中文也会遇到问题,需要在配置文件添加<code>environment=LANG=&quot;en_US.utf8&quot;, LC_ALL=&quot;en_US.UTF-8&quot;, LC_LANG=&quot;en_US.UTF-8&quot;</code>解决</li>
<li>写配置文件的时候一个变量不能配置多行,我一开始因为environment太长。写了2行，导致后面的没生效，折腾好久</li>
<li>修改supervisor配置文件后，如果配置文件错了，不会报错！而且supervisor没有工具能对配置文件的正确性进行检查，灰常操蛋啊！</li>
<li>supervisor可以检查到异常自动重启并设置最大重启次数，可是有时候会造成无限重启这种情况。因为重启后立刻退出才会触发最大重启次数机制，假如程序一直是运行了十分钟自动退出。那么会造成无限重启，可以使用它的api写一个脚本监控这种情况，进行警告</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xmlrpc.client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_time</span><span class="params">(name: str, interval: int, times: int)</span>:</span></span><br><span class="line">    s = xmlrpc.client.ServerProxy(<span class="string">'http://localhost:9001'</span>)</span><br><span class="line">    <span class="keyword">if</span> s.supervisor.getProcessInfo(name).get(<span class="string">'statename'</span>) != <span class="string">'RUNNING'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    context = s.supervisor.readLog(<span class="number">0</span>, <span class="number">10</span> * <span class="number">1024</span> * <span class="number">100</span>)</span><br><span class="line">    context = filter(<span class="keyword">lambda</span> x: name <span class="keyword">in</span> x <span class="keyword">and</span> <span class="string">'spawn'</span> <span class="keyword">in</span> x, context.splitlines())</span><br><span class="line">    context = map(<span class="keyword">lambda</span> x: datetime.strptime(x[:<span class="number">19</span>], <span class="string">'%Y-%m-%d %H:%M:%S'</span>), context)</span><br><span class="line">    context = list(filter(<span class="keyword">lambda</span> x: x + timedelta(minutes=interval) &gt; datetime.now(), context))</span><br><span class="line">    <span class="keyword">return</span> (len(context) &gt; times) <span class="keyword">and</span> len(context)</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://in355hz.iteye.com/blog/1860787">也谈 Python 的中文编码处理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写几条自己用supervisor遇到的一些小坑&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://python3wos.appspot.com/&quot;&gt;Python 3 Wall&lt;/a&gt;的反派代表，一直不能使用python3安装&lt;/li&gt;
&lt;li&gt;对中文输出支持奇差，
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>半自动刷网络课程</title>
    <link href="https://www.zoulei.net/2016/11/08/network_course_pass/"/>
    <id>https://www.zoulei.net/2016/11/08/network_course_pass/</id>
    <published>2016-11-08T14:04:28.000Z</published>
    <updated>2016-11-08T14:04:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>刷一个网络课程，很常见的那种，播放视频统计观看时长。不过该系统比较弱，即使切换到别的页面一样也会计算时长。限制条件只是偶尔会出现一些问答题让视频暂停且一个视频播放完成后不会自动播放下一个视频。最开始是打算直接模拟发送http请求，不过后面感觉或许有坑就选了另外一种办法。讲课肯定是有声音的，用程序去捕获声音，如果五秒钟没有声音则认为有问答题出现或者该章节讲完了。</p>
<a id="more"></a>
<h3 id="模拟请求法"><a href="#模拟请求法" class="headerlink" title="模拟请求法"></a>模拟请求法</h3><p>通过chrome开发者工具可以知道每60秒会发送一个请求，大概如下(某些信息*号替代)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /home/scorm/rte?cmd=submit&#38;token=68&#38;uid=null&#38;cwid=20&#38;eplanid=17245&#38;dig=************ HTTP/1.1&#10;Host: ******&#10;Connection: keep-alive&#10;Content-Length: 58&#10;Pragma: no-cache&#10;Cache-Control: no-cache&#10;Origin: *********&#10;X-Requested-With: ShockwaveFlash/23.0.0.205&#10;User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36&#10;Content-Type: text/xml&#10;Accept: */*&#10;Referer: *****htmlv1player_template_index.swf?1478605419919&#10;Accept-Encoding: gzip, deflate&#10;Accept-Language: zh-CN,zh;q=0.8&#10;Cookie: *********&#10;&#10;cmd:submit&#10;token:68&#10;uid:null&#10;cwid:20&#10;eplanid:17245&#10;dig:*****</span><br></pre></td></tr></table></figure></p>
<p>可以看到cookie信息登录后就会有，要拼凑出以上信息只需要知道dig是如何产生的。从X-Requested-With: ShockwaveFlash/23.0.0.205我们就能看出来是flash发送的，然后下载页面的swf文件进行反编译就能知道dig产生的逻辑。把swf文件放入<a href="http://www.showmycode.com/">http://www.showmycode.com/</a>就能看到产生的逻辑了。不过我不会as，他产生的代码也异常糟糕，截取一段如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5String = (md5String + _md5PrivateKey);&#10;md5String = MD5.hash(md5String);&#10;req = new URLRequest((_serviceUrlHasQuery) ? ((((((((((_serviceUrl + &#34;&#38;cmd=submit&#38;token=&#34;) + _token) + &#34;&#38;uid=&#34;) + _uid) + &#34;&#38;cwid=&#34;) + _cwid) + &#34;&#38;eplanid=&#34;) + _cplanid) + &#34;&#38;dig=&#34;) + md5String) : ((((((((((_serviceUrl + &#34;?cmd=submit&#38;token=&#34;) + _token) + &#34;&#38;uid=&#34;) + _uid) + &#34;&#38;cwid=&#34;) + _cwid) + &#34;&#38;eplanid=&#34;) + _cplanid) + &#34;&#38;dig=&#34;) + md5String));&#10;req.method = URLRequestMethod.POST;&#10;req.contentType = &#34;text/xml&#34;;&#10;_currentSubmitData = xml;&#10;req.data = xml;&#10;_urlLoader.load(req);</span><br></pre></td></tr></table></figure></p>
<p>如果你对as非常熟悉看起来估计没啥问题。可是有更好的方案。开源软件<a href="https://github.com/jindrapetrik/jpexs-decompiler">jpexs-decompiler</a>.而且居然有中文语言包。很牛的一点就是它能够直接编辑编反编译后的代码再重新打包，可以看看它生成的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this._token++;&#10;md5String = this._token + &#34;&#34; + this._uid + &#34;&#34; + this._cwid + &#34;&#34; + this._cplanid + &#34;&#34; + tmpTime;&#10;xml = &#34;&#60;request lastAccess=\&#34;&#34; + this._lastAccess + &#34;\&#34; sessionTime=\&#34;&#34; + tmpTime + &#34;\&#34;&#62;&#34;;&#10;for each(tmpObj in tmpHash)&#10;&#123;&#10;   if(tmpHash[&#34;sco_&#34; + tmpObj.id] == null)&#10;   &#123;&#10;      tmpObj2 = this._tracksHash[&#34;sco_&#34; + tmpObj.id];&#10;      if(tmpObj2 != null)&#10;      &#123;&#10;         xml = xml + &#34;&#60;item id=\&#34;&#34; + tmpObj2.id + &#34;\&#34; score=\&#34;&#34; + tmpObj2.score + &#34;\&#34; time=\&#34;&#34; + tmpObj2.time + &#34;\&#34;/&#62;&#34;;&#10;         tmpHash[&#34;sco_&#34; + tmpObj.id] = tmpObj2;&#10;         md5String = md5String + tmpObj2.id + tmpObj2.score;&#10;      &#125;&#10;   &#125;&#10;&#125;&#10;for each(objTemp in tmpHash)&#10;&#123;&#10;   xml = xml + &#34;&#60;item id=\&#34;&#34; + objTemp.id + &#34;\&#34; complete=\&#34;&#34; + objTemp.complete + &#34;\&#34; type=\&#34;obj\&#34;/&#62;&#34;;&#10;&#125;&#10;xml = xml + &#34;&#60;/request&#62;&#34;;&#10;this._cmd = &#34;submit&#34;;&#10;md5String = md5String + this._md5PrivateKey;&#10;ExternalInterface.call(&#34;console.log&#34;,md5String);&#10;md5String = MD5.hash(md5String);&#10;req = new URLRequest(!!this._serviceUrlHasQuery?this._serviceUrl + &#34;&#38;cmd=submit&#38;token=&#34; + this._token + &#34;&#38;uid=&#34; + this._uid + &#34;&#38;cwid=&#34; + this._cwid + &#34;&#38;eplanid=&#34; + this._cplanid + &#34;&#38;dig=&#34; + md5String:this._serviceUrl + &#34;?cmd=submit&#38;token=&#34; + this._token + &#34;&#38;uid=&#34; + this._uid + &#34;&#38;cwid=&#34; + this._cwid + &#34;&#38;eplanid=&#34; + this._cplanid + &#34;&#38;dig=&#34; + md5String);&#10;req.method = URLRequestMethod.POST;&#10;req.contentType = &#34;text/xml&#34;;&#10;this._currentSubmitData = xml;&#10;req.data = xml;&#10;this._urlLoader.load(req);</span><br></pre></td></tr></table></figure></p>
<p>这样看起来就很容易理解了，写成python代码大概就是这样子(反编译后可以看到key)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Request Payload</span></span><br><span class="line"><span class="comment"># &lt;request lastAccess="ch_00_02" sessionTime="60"&gt;&lt;/request&gt;</span></span><br><span class="line"><span class="comment"># &lt;response success="true"&gt;</span></span><br><span class="line"><span class="comment"># &lt;item complete="0" id="ch_00_02" score="0.0" time="2249" /&gt;</span></span><br><span class="line"><span class="comment"># &lt;/response&gt;</span></span><br><span class="line"><span class="comment"># &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;response success="true"&gt;&lt;item complete="0" id="ch_00_02" score="0.0" time="2249"/&gt;&lt;/response&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># http://***?cmd=submit&amp;token=5&amp;uid=null&amp;cwid=67&amp;eplanid=17242&amp;dig=*****</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line">pri = <span class="string">'#Huaxia$RTE-*PP'</span></span><br><span class="line">a = <span class="string">'1null671724260#Huaxia$RTE-*PP'</span></span><br><span class="line">b = md5(a).hexdigest()</span><br></pre></td></tr></table></figure><br>另外如果遇到什么疑惑可以直接<code>ExternalInterface.call(&quot;console.log&quot;,md5String);</code>这样能够输出变量。重新打包为swf，再用fiddler替换掉请求的swf文件为自己打包的文件，这样就能看到调试输出了。感慨下这个工具真好用，不过本人不是搞前端的，而且flash也已经没落到没有去深入的必要┑(￣Д ￣)┍</p>
<h3 id="判断视频是否播放完成半自动化"><a href="#判断视频是否播放完成半自动化" class="headerlink" title="判断视频是否播放完成半自动化"></a>判断视频是否播放完成半自动化</h3><p>我判断的依据是没有声音了，需要解决的就是获取当前音量大小的问题。最开始想的是使用系统的命令行接口，无奈并没有找到，而后看到了使用虚拟音频接口<a href="https://github.com/mattingalls/Soundflower">Soundflower</a>,虽然2年没更新过了，惊奇的是能正常使用。安装上之后在sound里面的input和output会多出2个设备，如图<img src="https://ficapy.b0.upaiyun.com/blogimg/soundflower.png" alt="soundflower">,当你需要捕获系统声音的时候将input和output均选为同一个(这样会导致机器没有声音输出，需要选择同一个的原因我觉得是代码中根据input的文件描述符来获得output,所以需要将input和output选为同一个)，然而我单独开了一个windows虚拟机，虚拟机可以选择使用哪个输入输出音频接口，对于虚拟机的输出我选择了soundflower，在系统设置里面我选择了相同的soundeflower作为输入。可是选择了正常的接口作为输出。如此我听不到虚拟机发出的声音，同时本机发出的声音又可以正常收听，完美~~~<br>代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import time&#10;import pyaudio&#10;import audioop&#10;from collections import deque&#10;from subprocess import Popen&#10;&#10;FORMAT = pyaudio.paInt16&#10;CHANNELS = 2&#10;RATE = 44100&#10;CHUNK = 1024&#10;&#10;audio = pyaudio.PyAudio()&#10;&#10;stream = audio.open(format=FORMAT, channels=CHANNELS,&#10;                    rate=RATE, input=True,&#10;                    frames_per_buffer=CHUNK)&#10;&#10;flag = time.time()&#10;queue = deque(maxlen=5)&#10;while True:&#10;    data = stream.read(CHUNK)&#10;    if time.time() - flag &#62; 1:&#10;        flag = time.time()&#10;        rms = audioop.rms(data, 2)&#10;        print rms&#10;        queue.append(rms)&#10;        if len(queue) == 5 and sum(queue) == 0:&#10;            Popen(&#34;&#34;&#34;/usr/bin/osascript -e &#39;display notification &#34;look here&#34; &#39;&#34;&#34;&#34;, shell=True)</span><br></pre></td></tr></table></figure></p>
<p>当五秒钟没有声音就在屏幕右上角弹出一个提示框提醒你去点击。本文用于osx系统，其他系统按照这个思路应该也能实现</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>当然这个系统还有很<code>贴心</code>的地方，对于视频讲解中出现的问答题，其实在前端页面中已经给出了答案，打开web控制台，查看一下就有哒。<br>然后还不允许复制粘贴。这个同样直接在控制台里面复制就好了，也没必要禁用js啥的~~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.christianengvall.se/record-audio-soundflower/">record-audio-soundflower</a><br><a href="http://stackoverflow.com/questions/26478315/getting-volume-levels-from-pyaudio-for-use-in-arduino">getting-volume-levels-from-pyaudio-for-use-in-arduino</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷一个网络课程，很常见的那种，播放视频统计观看时长。不过该系统比较弱，即使切换到别的页面一样也会计算时长。限制条件只是偶尔会出现一些问答题让视频暂停且一个视频播放完成后不会自动播放下一个视频。最开始是打算直接模拟发送http请求，不过后面感觉或许有坑就选了另外一种办法。讲课肯定是有声音的，用程序去捕获声音，如果五秒钟没有声音则认为有问答题出现或者该章节讲完了。&lt;/p&gt;
    
    </summary>
    
      <category term="伪技术" scheme="https://www.zoulei.net/categories/%E4%BC%AA%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="https://www.zoulei.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Flask路由机制</title>
    <link href="https://www.zoulei.net/2016/09/11/flask_routing_note/"/>
    <id>https://www.zoulei.net/2016/09/11/flask_routing_note/</id>
    <published>2016-09-11T14:06:12.000Z</published>
    <updated>2016-09-11T14:11:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Flask帅气的Hello World示例让人印象深刻。其中使用装饰器的路由写法功不可没，甚至以前看过一个系列<a href="http://ains.co/blog/things-which-arent-magic-flask-part-1.html">没那么神奇</a>，讲了app.route。是的，它好像并没有那么神奇，我也来解析一下😆</p>
<a id="more"></a>
<p>Flask的路由是对werkzeug进行了简单的包装，做成了app.route装饰器和blueprint。其实werkzeug中有一段docstring就能反映出flask的路由机制(MapAdapter.dispatch)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.wrappers <span class="keyword">import</span> Request, Response</span><br><span class="line"><span class="keyword">from</span> werkzeug.wsgi <span class="keyword">import</span> responder</span><br><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> Map, Rule</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Response(<span class="string">'Hello from the index'</span>)</span><br><span class="line"></span><br><span class="line">url_map = Map([Rule(<span class="string">'/'</span>, endpoint=<span class="string">'index'</span>)])</span><br><span class="line">views = &#123;<span class="string">'index'</span>: on_index&#125;</span><br><span class="line"></span><br><span class="line"><span class="decorator">@responder</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    request = Request(environ)</span><br><span class="line">    urls = url_map.bind_to_environ(environ)</span><br><span class="line">    <span class="keyword">return</span> urls.dispatch(<span class="keyword">lambda</span> e, v: views[e](request, **v),</span><br><span class="line">                         catch_http_exceptions=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>werkzeug路由的全部实现都在routing.py文件当中，看它就够了。路由的基本功能可以说是</p>
<ol>
<li>给出一个URL，匹配到它对应的处理函数，</li>
<li>给出函数能反推构造出URL</li>
</ol>
<h2 id="Rule"><a href="#Rule" class="headerlink" title="Rule"></a>Rule</h2><p>一个Rule就是一条URL匹配规则,它的模式如下<code>&lt;converter(arguments):name&gt;</code>,使用正则匹配找出我们需要的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_rule_re = re.compile(r&#39;&#39;&#39;&#10;    (?P&#60;static&#62;[^&#60;]*)                           # static rule data&#10;    &#60;&#10;    (?:&#10;        (?P&#60;converter&#62;[a-zA-Z_][a-zA-Z0-9_]*)   # converter name&#10;        (?:\((?P&#60;args&#62;.*?)\))?                  # converter arguments&#10;        \:                                      # variable delimiter&#10;    )?&#10;    (?P&#60;variable&#62;[a-zA-Z_][a-zA-Z0-9_]*)        # variable name&#10;    &#62;&#10;&#39;&#39;&#39;, re.VERBOSE)</span><br></pre></td></tr></table></figure></p>
<p>大概是这么个样子rule匹配<br><img src="https://ficapy.b0.upaiyun.com/blogimg/werkzeug_rule_re.png" alt="werkzeug_rule_re"><br>convert规则匹配<br><img src="https://ficapy.b0.upaiyun.com/blogimg/werkzeug_converter_args_re.png" alt="werkzeug_converter_args_re"><br>很容易想到使用这2个正则能够匹配一个URL，一看他是否匹配某个rule，其次如果匹配那么提取出rule中的参数和值,比如<code>/&lt;int:id&gt;</code>就能匹配<code>/16</code>这个url且得到id=16。这2个函数就是match和build了<br>仅仅有它们是不够的。我们需要的不仅仅是一条Rule，我们需要的是所有Rule的集合。当我们每创建一个Rule的时候将它加入到集合中。所以它提供了get_rules和bind方法</p>
<p>Rule对象同时有2个非常重要的属性endpoint和_regex(编译后的正则).endpoint不用说匹配返回它，根据它返回构建好的URL，匹配功能则是由_regex对象提供的。另外有几个对象继承自Rule<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subdomain           self.subdomain&#10;Submount            self.rule = self.path + self.rule&#10;EndpointPrefix      self.endpoint = self.prefix + self.endpoint</span><br></pre></td></tr></table></figure></p>
<p>可以看出这三个对象都是对Rule的属性进行了小幅度修改,其中subdomain和submount修改的最终结果就是改变了_regex对象</p>
<p>说一下Subdomain,子域名。这玩意儿好像并不常用，一般一个子域名就是单独一个项目了，不大会几个子域名混合在一个项目里面。如果要使用子域名需要设置SERVER_NAME。示例如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SERVER_NAME'</span>] = <span class="string">'app.local:5000'</span></span><br><span class="line"><span class="decorator">@app.route('/',subdomain='blog')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello'</span></span><br><span class="line">app.run(<span class="string">'app.local'</span>)</span><br></pre></td></tr></table></figure><br>然后就是在host里面添加就可以正常调试子域名了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 app.local&#10;127.0.0.1 blog.app.local</span><br></pre></td></tr></table></figure></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map的作用就是将所有的Rule组合在一起,所以add函数是必须的,Rule对象中的match和build都只是针对自己的，Map中提供的match和build则是针对所有Rule的。比如在Flask中写app.route必然会调用add，将该Rule添加到Map中。代码如下(0.1版本)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_url_rule</span><span class="params">(self, rule, endpoint, **options)</span>:</span></span><br><span class="line">    options[<span class="string">'endpoint'</span>] = endpoint</span><br><span class="line">    options.setdefault(<span class="string">'methods'</span>, (<span class="string">'GET'</span>,))</span><br><span class="line">    self.url_map.add(Rule(rule, **options))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, rule, **options)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">      self.add_url_rule(rule, f.__name__, **options)</span><br><span class="line">      self.view_functions[f.__name__] = f</span><br><span class="line">      <span class="keyword">return</span> f</span><br><span class="line">  <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><br>代码中self.url_map = Map(),可以看到app.route做了2件事情，加入到Map中，加入到了view_functions字典中(endpoint对应函数,这段代码和文章开头的代码是很相似的)</p>
<p>Map对象中有2个属性也是比较重要的,_rules列表和_rules_by_endpoint字典。前者存放所有Rule对象，匹配的时候用来遍历，后者为endpoint到Rule的映射。用来build重组URL</p>
<p>现在再来看看Flask中的dispatch分发逻辑<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Does the request dispatching.  Matches the URL and returns the</span><br><span class="line">    return value of the view or error handler.  This does not have to</span><br><span class="line">    be a response object.  In order to convert the return value to a</span><br><span class="line">    proper response object, call :func:`make_response`.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        endpoint, values = self.match_request()</span><br><span class="line">        <span class="keyword">return</span> self.view_functions[endpoint](**values)</span><br><span class="line">    <span class="keyword">except</span> HTTPException, e:</span><br><span class="line">        handler = self.error_handlers.get(e.code)</span><br><span class="line">        <span class="keyword">if</span> handler <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        <span class="keyword">return</span> handler(e)</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        handler = self.error_handlers.get(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">if</span> self.debug <span class="keyword">or</span> handler <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">return</span> handler(e)</span><br></pre></td></tr></table></figure><br>匹配请求得到endpoint再从view_function中得到对应的处理函数执行</p>
<h2 id="Blueprint"><a href="#Blueprint" class="headerlink" title="Blueprint"></a>Blueprint</h2><p>@app.route虽然够炫酷，可是它绝不适应于大项目。因为注册的endpoint就是函数的名称，在大项目中绝对会存在重名函数的。Blueprint的解决办法就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blueprint = Blueprint(&#39;public&#39;, __name__, static_folder=&#39;../static&#39;)&#10;@blueprint.route(&#39;/&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])&#10;def index()&#10;&#10;app.register_blueprint(blueprint)</span><br></pre></td></tr></table></figure></p>
<p>这样它注册的endpoint就会变成public.index，解决了重名问题</p>
<p>有人问为什么endpoint不直接使用对应的函数，而要使用字符串。我认为是使用url_for等构建URL函数的时候需要它是字符串，因为使用装饰器后func = deactor(func)，你使用@app.route之后注册的func和你现在的func不是同一个对象。构建函数将无法使用,这也告诉了我们,任何时候其他的装饰器都需要写在@app.route下面,因为如果写在上面，你注册的那个函数是不包含上面的装饰器的，注定了上面的装饰器无法执行</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask帅气的Hello World示例让人印象深刻。其中使用装饰器的路由写法功不可没，甚至以前看过一个系列&lt;a href=&quot;http://ains.co/blog/things-which-arent-magic-flask-part-1.html&quot;&gt;没那么神奇&lt;/a&gt;，讲了app.route。是的，它好像并没有那么神奇，我也来解析一下😆&lt;/p&gt;
    
    </summary>
    
      <category term="Flask" scheme="https://www.zoulei.net/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://www.zoulei.net/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask插件原理</title>
    <link href="https://www.zoulei.net/2016/09/05/flask_plugin_note/"/>
    <id>https://www.zoulei.net/2016/09/05/flask_plugin_note/</id>
    <published>2016-09-04T23:38:32.000Z</published>
    <updated>2016-09-11T14:08:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Flask的插件还挺多,用过的都知道比如flask-sqlalchemy,安装的时候是使用pip install flask-sqlalchemy，使用的时候就成了from flask.ext.sqlalchemy import SQLAlchemy。使用的是flask.ext而不是flask_sqlalchemy。感觉还有点牛掰啊-_-，不过仅仅是看起来高大上，并没有什么卵用。<a href="https://github.com/pallets/flask/issues/1135">在2016年4月13号正式被移出支持了</a>，已经直接发出不建议使用的警告。本文还是来炒一下现饭，看看它背后的逻辑</p>
<a id="more"></a>
<p>比如flask-sqlalchemy原本是使用from flask_sqlalchemy import [anything]使用的，被变成了from flask.ext.sqlalchemy import [anything]。这是一种对于import的hook。我们知道要导入一个模块，不使用import声明也是可以的，可以使用__import__函数，返回得到的也是一个模块对象</p>
<h2 id="import-hook"><a href="#import-hook" class="headerlink" title="import hook"></a>import hook</h2><p>下文简述，如果需要了解比较详细的资料可以查看后文给出的参考链接(python2和3的import机制是略有区别的)<br>import声明主要做了2件事情，查找模块，加载模块。我们说的hook发生在第一步查找模块。查找模块的步骤是</p>
<ol>
<li>查找sys.modules缓存</li>
<li>在sys.meta_path中依次执行finder对象,找到就返回自身,所有的都没有找到则会报错<br>注意:sys.path_hooks中的finder会被sys.meta_path调用执行(sys.meta_path和sys.path_hook都可以参与import hooks步骤)</li>
</ol>
<h2 id="精简版本实现"><a href="#精简版本实现" class="headerlink" title="精简版本实现"></a>精简版本实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtensionImporter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">install</span><span class="params">(self)</span>:</span></span><br><span class="line">        sys.meta_path[:] = [x <span class="keyword">for</span> x <span class="keyword">in</span> sys.meta_path <span class="keyword">if</span> self != x] + [self]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_module</span><span class="params">(self, fullname, path=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> fullname.startswith(<span class="string">'flask.ext.'</span>):</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_module</span><span class="params">(self, fullname)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> fullname <span class="keyword">in</span> sys.modules:</span><br><span class="line">            <span class="keyword">return</span> sys.modules[fullname]</span><br><span class="line"></span><br><span class="line">        modname = fullname.split(<span class="string">'.'</span>)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        realname = <span class="string">'flask_'</span> +  modname</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            __import__(realname)</span><br><span class="line">        <span class="keyword">except</span> ImportError:</span><br><span class="line">            <span class="keyword">raise</span> ImportError(<span class="string">'No module named %s'</span> % fullname)</span><br><span class="line"></span><br><span class="line">        module = sys.modules[fullname] = sys.modules[realname]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">not</span> <span class="keyword">in</span> modname:</span><br><span class="line">            setattr(sys.modules[<span class="string">'flask.ext'</span>], modname, module)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> module</span><br></pre></td></tr></table></figure>
<p>ExtensionImporter是一个finder对象,当执行import flask.ext时会把它加入到sys.meta_path列表，后续的import都会先执行它，判断满足要求后就会使用__import__导入然后加入到sys.modules，这样就实现了flask.ext.sqlalchemy导入</p>
<p>为什么会被废除呢。下面是我猜测的。首先本来这个东西没有实质的作用，就是看着炫酷而已。我们可以认为所有的扩展导入都会使用flask.ext.xxx，但是这对第三方扩展库是有要求的，那就是包名必须为flask_xxx才行，我猜测有的第三方库未必遵守这个规则(否则exthook.py中也不会出现['flask_%s', 'flaskext.%s'flaskext.另外一种形式)，这就说明了有的作者使用了flaskextxxx这种包名。出现了第二种难免就会出现另外的。当使用者发现并非所有的第三方扩展都使用flask.ext导入的时候。社区也觉得没必要维持了，毕竟第一个写这个代码的人是不是因为刚刚了解了import机制，觉得很炫酷写上去的呢-_-,另外这种花哨的设计也可能对代码自动补全功能产生了负面影响。so，最后还是回到了原来的位置，直接使用import flask_sqlalchemy导入吧</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.python.org/3/reference/import.html#import-hooks">官方import hook文档</a><br><a href="https://github.com/Liuchang0812/slides/tree/master/pycon2015cn">pycon2015 import演讲</a><br><a href="https://github.com/mitsuhiko/flask-sqlalchemy">flask-sqlalchemy</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask的插件还挺多,用过的都知道比如flask-sqlalchemy,安装的时候是使用pip install flask-sqlalchemy，使用的时候就成了from flask.ext.sqlalchemy import SQLAlchemy。使用的是flask.ext而不是flask_sqlalchemy。感觉还有点牛掰啊-_-，不过仅仅是看起来高大上，并没有什么卵用。&lt;a href=&quot;https://github.com/pallets/flask/issues/1135&quot;&gt;在2016年4月13号正式被移出支持了&lt;/a&gt;，已经直接发出不建议使用的警告。本文还是来炒一下现饭，看看它背后的逻辑&lt;/p&gt;
    
    </summary>
    
      <category term="Flask" scheme="https://www.zoulei.net/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://www.zoulei.net/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>tmux</title>
    <link href="https://www.zoulei.net/2016/09/02/tmux_note/"/>
    <id>https://www.zoulei.net/2016/09/02/tmux_note/</id>
    <published>2016-09-02T07:43:22.000Z</published>
    <updated>2016-09-04T07:33:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>自screen之后tmux早已身名远扬，然而这个东西对于一般人来说好像并没有什么卵用，好像还比较麻烦。这也是我以前的看法。主要原因就是iterm2已经非常完美了。iterm2的好用一定程度上掩盖了tmux的光辉。因为iterm2是开箱即用,tmux不配置不一定用的舒服。直到某一天我在youtube上看到了2个视频，我知道我该改改了:)<br><img src="https://ficapy.b0.upaiyun.com/blogimg/gotbletu_tmux.png" alt="gotbletu_tmux"><br>我个人也是刚入门,下面介绍一些基本知识，希望对读者有所帮助.</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>tmux分客户端和服务端，这个docker这种是很相似的，我们操作的只是针对客户端，服务端以守护进程运行，这样实现了我们退出后下次再进入依旧保持了运行状态</li>
<li>session:比如你在公司有个工作环境，在家里又是另外一个工作环境。这2个环境差别非常大。那么就使用2个不同的session</li>
<li>window:你在工作环境中要打开多个软件，聊天的、BT下载的、听歌的etc</li>
<li>pane:一个软件要分成多个区域输出</li>
<li>当然一般来说越少是越方便切换的。就个人来说一个session就够了,主要切换来自于window和pane</li>
<li>tmux主要来说最重要的就是对各个窗口的切换排列管理，各种键位绑定也是用于对窗口的切换</li>
</ul>
<h2 id="windows-pane基本设置"><a href="#windows-pane基本设置" class="headerlink" title="windows,pane基本设置"></a>windows,pane基本设置</h2><p>和vim一样tmux也是使用一个主要的prefix key，先输入prefix key之后再输入绑定的字母执行操作.下面就将我从多个地方copy来的配置解释一番-_-</p>
<p>设置成C-a,同时解绑原来的C-b,最后的bind a的作用就是:C-a本来是回到行首的快捷键，被tmux使用之后使用此设定变成了C-a-a到行首</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set -g prefix ^a&#10;unbind ^b&#10;bind a send-prefix</span><br></pre></td></tr></table></figure>
<p>之后就是对window和pane的快捷键设定，本人使用vim相似的快捷键设定。这个好像没啥好说的，比如hjkl在pane中移动,s、v分屏，使用&lt;、&gt;、+、_对pane进行大小的改变，使用C-u、C-d进行交换，使用q、C-q进行关闭pane和window，举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind k selectp -U&#10;bind -r &#60; resize-pane -L 10&#10;bind ^u swapp -U&#10;bind q killp</span><br></pre></td></tr></table></figure>
<p>使用-r(recursion)就能够输入一次&lt;之后马上多次输入&lt;、&gt;有效,这对于调整大小时是非常有用的。。。,没有被重写的配置基本都是非常好记的单词,c、n、w、d记这些都是毫不费力的</p>
<h2 id="鼠标、复制及清屏设置"><a href="#鼠标、复制及清屏设置" class="headerlink" title="鼠标、复制及清屏设置"></a>鼠标、复制及清屏设置</h2><p>如果你不进行其他设置可能用几下动一下鼠标上下翻一下，就会高呼WTF。毕竟完全不动鼠标的大神不多，我还是打开鼠标设置吧,这样也能同时使用鼠标进行上下滑动了，其次复制也和以前不一样了，特别是如果你分了2个竖向的pane,这样和以前一样用鼠标复制就出问题了，当然你可以用z(zoom)全屏当前的pane，然后用鼠标复制。然而一个vim党是不会这样做的T_T。下面是设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setw -g mouse on&#10;#set vi mode for copy mode&#10;setw -g mode-keys vi&#10;&#10;# more settings to make copy-mode more vim-like&#10;unbind [&#10;bind Escape copy-mode&#10;unbind p&#10;bind p paste-buffer&#10;bind -t vi-copy &#39;v&#39; begin-selection&#10;bind -t vi-copy &#39;y&#39; copy-selection&#10;&#10;# Buffers to/from Mac clipboard, yay tmux book from pragprog&#10;bind C-c run &#34;tmux save-buffer - | reattach-to-user-namespace pbcopy&#34;&#10;bind C-v run &#34;tmux set-buffer $(reattach-to-user-namespace pbpaste); tmux paste-buffer&#34;</span><br></pre></td></tr></table></figure>
<p>这样复制好像变得复杂了。。。需要先进入选择模式C-a-ESC-v选择需要复制的内容后再执行y复制到tmux的缓冲区，另外像tmux和vim这种的粘贴板是独立的,和osx系统的粘贴板不共通,如果要再复制到系统粘贴板，此时再使用C-a-C-c,好像是比较复杂啊。。你可以按住option再用鼠标选择也是直接复制到系统粘贴板，要让vim和tmux和系统粘贴板通用，你需要<code>brew install reattach-to-user-namespace</code>安装。另外iterm2其实是可以让他们共用的，下图选中Applications in terminal may access clipboard也能达到同样的效果，不过下面的参考文章有说有缺点-_-我就听了他的了<br><img src="https://ficapy.b0.upaiyun.com/blogimg/iterm_access_clipboard.png" alt="iterm_access_clipboard"></p>
<p>再就是配置重载和清屏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#bind -n C-l send-keys &#39;C-l&#39;&#10;bind -n C-k send-keys -R \; send-keys C-l \; clear-history&#10;# reload config (prefix r)&#10;bind r source ~/.tmux.conf \; display &#34;Configuration reloaded!&#34;</span><br></pre></td></tr></table></figure>
<p>就好像command+k完全清屏，tmux也可以，不过需要配置(这个完美清屏命令找了很久),-n表示不需要先按prefix key直接使用C-k就调用了，另外不要将C-l设置为清屏,会让TAB补全失效</p>
<h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><p>配置一个好看的状态栏好像还是比较困难的,我比较偷懒就直接使用了<a href="https://github.com/erikw/tmux-powerline">tmux-powerline</a>和<a href="https://github.com/seebi/tmux-colors-solarized/blob/master/tmuxcolors-256.conf">tmux-colors-solarized</a>,下面是效果<br><img src="https://ficapy.b0.upaiyun.com/blogimg/tmux_statusbar.png" alt="tmux_statusbar"><br>注意配置powerline的时候可能需要在~/.zshrc中加入<code>PS1=&quot;$PS1&quot;&#39;$([ -n &quot;$TMUX&quot; ] &amp;&amp; tmux setenv TMUXPWD_$(tmux display -p &quot;#D&quot; | tr -d %) &quot;$PWD&quot;)&#39;</code>有的时候修改配置可能需要tmux kill-server后重新进入才能看到效果</p>
<p>在状体栏的配置会看到这种<code>set-option -g status-bg colour235</code>,colour235是什么鬼颜色。真是不好猜啊，可以单独开一个pane打印输出所有256种颜色，自己对比修改成喜欢的颜色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;0..255&#125; ; do&#10;    printf &#34;\x1b[38;5;$&#123;i&#125;mcolour$&#123;i&#125;\n&#34;&#10;done</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>我们设置好了之后可能需要在打开iterm之后就直接进入tmux,否则岂不是白忙活~(≧▽≦)/~啦啦啦，很简单,在iterm的设置页profiles→General→Send text at start中填入<code>tmux attach -t init || tmux new -s init</code>,更有用的是在我们远程到vps上的时候直接进入到tmux,设置一个别名如下<code>alias hg=&quot;ssh -t hg \&quot;bash -c &#39;tmux a -t init || tmux new -s init&#39;\&quot;&quot;</code>这样我们执行hg的时候就新建一个session或者连接到已有的session</p>
<p>如果我们本地开一个tmux，然后远程连接vps，vps再运行tmux，这会造成嵌套使用。特别是当你的prefix key还是一样的时候。。。悲催了，你所输入的快捷键只会被本地的tmux处理而不会被远程的tmux响应，要处理这个问题可以将2者的prefix key设置成不一样,比如一个为a另外一个为s。或者使用iterm单独开一个窗口，我更推荐后者,因为设置成不同的prefix key输入快了可能就输入混淆啦。</p>
<p>另外,使用了tmux显著增加了iterm2的耗电量,估计是我设置的那个状态栏显示上传下载流量导致的，每几秒刷新执行一次shell或许挺耗电.</p>
<p><a href="https://github.com/ficapy/dotfiles/blob/master/.tmux.conf">我的tmux配置</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://danielmiessler.com/study/tmux/">A tmux Primer</a><br><a href="https://www.youtube.com/playlist?list=PL5BE1545D8486D66D">gotbletu youtube playlist</a><br><a href="https://evertpot.com/osx-tmux-vim-copy-paste-clipboard/">Making the clipboard work between iTerm2, tmux, vim and OS X.</a><br><a href="http://superuser.com/questions/285381/how-does-the-tmux-color-palette-work">How does the tmux color palette work?</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自screen之后tmux早已身名远扬，然而这个东西对于一般人来说好像并没有什么卵用，好像还比较麻烦。这也是我以前的看法。主要原因就是iterm2已经非常完美了。iterm2的好用一定程度上掩盖了tmux的光辉。因为iterm2是开箱即用,tmux不配置不一定用的舒服。直到某一天我在youtube上看到了2个视频，我知道我该改改了:)&lt;br&gt;&lt;img src=&quot;https://ficapy.b0.upaiyun.com/blogimg/gotbletu_tmux.png&quot; alt=&quot;gotbletu_tmux&quot;&gt;&lt;br&gt;我个人也是刚入门,下面介绍一些基本知识，希望对读者有所帮助.&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://www.zoulei.net/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>fasd和fzf</title>
    <link href="https://www.zoulei.net/2016/08/29/fasd&amp;fzf/"/>
    <id>https://www.zoulei.net/2016/08/29/fasd&amp;fzf/</id>
    <published>2016-08-29T13:55:24.000Z</published>
    <updated>2016-08-30T07:24:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>来2个日常使用命令行工具玩一玩，前一个是目录快速跳转，后一个是使用curses模糊查找</p>
<a id="more"></a>
<h2 id="fasd"><a href="#fasd" class="headerlink" title="fasd"></a><a href="https://github.com/clvv/fasd">fasd</a></h2><p>目录快速跳转工具挺多的autojump,z.我最开始用的是z，用长了感觉好像有bug,然后就换fasd.<code>好像</code>感觉好用那么一点点。这种工具原理都差不多。对你的历史输入进行统计，放入数据库。然后根据你输入的结果从数据库匹配达到快速cd的结果。安装好后直接输入fasd,就可以看到得分以及目录/文件。从它的原理也能可以看出来。它只能对有记录的快速切换(从你安装这个软件开始记录)。对于一个新的目录首次访问还是需要用cd。这个软件个常用的命令也就2个<br>z和v，分别代表切换目录和使用$EDITOR打开文件.所以:</p>
<ul>
<li>当你需要快速cd到以前打开过的目录用z,当你首次打开一个目录用cd(或者打开当前目录)；</li>
<li>当你需要用vim打开以前打开的文件用v,首次打开或确定目录vim</li>
<li>它真的很方便了,我看到有些人把它和fzf合起来一起用。我想了很久，除了装逼降低效率。我没想到有什么用</li>
</ul>
<h2 id="fzf"><a href="#fzf" class="headerlink" title="fzf"></a><a href="https://github.com/junegunn/fzf">fzf</a></h2><p>这款软件对于提高命令行效率也是很牛逼,而且看github上面的提交记录，依旧非常活跃(对于一个小白没什么比项目的活跃更重要了，因为它意味着你可能遇到的坑前人都可能已经趟过).而且这个项目的作者好像非常自信,项目说明里面居然只列举了优点，丝毫没有缺点.</p>
<p>这是一款安装上去就能让你眼前一亮的软件。比如Ctrl+R，完美替换了shell默认的历史记录功能,当输入指令的时候使用ctrl+T就能列出当前目录下所有的文件。当然这只是列举的2个最常用的功能,实际上，它的潜力远不止这么点，如果你用过osx上被人吹成神的alfred,那么fzf的概念可能和它有一定的相似性(取得一些结果,然后使用列表排除出来),举个例子,IDE中我们经常使用全局替换,用以下命令也能搞定<br><code>grep -rn &#39;python&#39;| fzf -m | awk -F &#39;:&#39; &#39;{print $1}&#39; | xargs -L 1 sed -i -e &#39;s/python/hello/g&#39;</code><br>效果如下<img src="https://ficapy.b0.upaiyun.com/blogimg/fzf_grep_sed.gif" alt="fzf_grep_sed"><br>解释一下，</p>
<ol>
<li>使用grep递归匹配当前目录含有python的文件,-r为递归，-n为显示行号。</li>
<li>使用fzf显示出来,-m为多行模式,使用tab为选择或者取消选择。</li>
<li>使用awk对选择的的结果进行处理,-F为选择分隔符，结果为多个目录</li>
<li>使用xargs对结果执行sed替换,-L为对每一个非空行执行后续命令(Call utility for every number non-empty lines read.  A line ending with a space continues to the next non-empty line)</li>
<li>另外grep的效率是非常高的,如果你直接用sed进行全局替换-_-文件一多还是很花费时间滴,比如这种<code>sed -i -- &#39;s/foo/bar/g&#39; **/*(D.)</code></li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>虽然作者没有列举出来,我还是就我的个人感觉说一下</p>
<ol>
<li>蠢到家的匹配效果,你很难理解它是根据什么给你匹配的,放一张图<img src="http://ficapy.b0.upaiyun.com/blogimg/fzf_match.png" alt="fzf_match">，就这匪夷所思的匹配，你不得不使用^$!等额外的规则或者多输入一些字符然后上下键选择</li>
<li>看着炫酷,有时候没必要那么炫酷，比如使用z的时候tab如果有多个选择，这个时候如果你用fzf替代，他会使用curses全屏让你选择,其实整个过程已经多输入了好多字符.</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>fasd和fzf的很好用，而且它们都不需要任何配置都能让你感到高效!对于fzf如果你花时间配置是有特别多玩法的，可以参照官网<a href="https://github.com/junegunn/fzf/wiki/examples">fzf_examples</a>和<a href="https://www.youtube.com/playlist?list=PLqv94xWU9zZ2fMsMMDF4PjtNHCeBFbggD">gotbletu的视频教程</a>体验它的强大。另外，如果你喜欢这2个软件，那么你一定会喜欢<a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a>试一试吧~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来2个日常使用命令行工具玩一玩，前一个是目录快速跳转，后一个是使用curses模糊查找&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://www.zoulei.net/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>使用shell修改osx的CapsLock映射</title>
    <link href="https://www.zoulei.net/2016/08/29/use_shell_modifier_capslock_map_on_osx/"/>
    <id>https://www.zoulei.net/2016/08/29/use_shell_modifier_capslock_map_on_osx/</id>
    <published>2016-08-29T03:24:33.000Z</published>
    <updated>2016-08-29T03:49:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于命令行爱好者,很多人会选择将黄金键盘位置CapsLock替换成Ctrl,有些人选择仅仅是和默认的Ctrl进行替换，有些人更极端，相当于去掉CapsLock键增加一个Ctrl位置。我选择后者。有时候会想。假如需要输入大段文字的时候一直按住Shift岂不是蛋疼。搜索了下，网上真有这个问题。而且有人还给出了答案。我就转发一下好了-_-</p>
<ul>
<li>首先你要知道在你的<code>system preferences→keyboard→modifiers keys</code>是可以修改CapsLock映射<br>到Ctrl的</li>
<li>其次使用applescript可以编辑脚本对GUI界面进行操作(系统还自带一个Script Editor,不得不吐槽一下,脚本真不美观)</li>
<li>脚本编写后执行需要到安全设置里面添加许可权限(<code>system preferences→security&amp;privacy→accessibility</code>,由于我使用的是iTerm,将它加入就好了)</li>
</ul>
<p>最后奉上脚本(添加至~/.zshrc,!!!!仅对英文系统有效,中文估计改一下也能用)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caps () &#123;&#10;&#9;osascript &#62; /dev/null &#60;&#60;EOF&#10;    tell application &#34;System Preferences&#34;&#10;        reveal anchor &#34;keyboardTab&#34; of pane &#34;com.apple.preference.keyboard&#34;&#10;    end tell&#10;    tell application &#34;System Events&#34; to tell window 1 of process &#34;System Preferences&#34;&#10;        click button 1 of tab group 1&#10;        tell sheet 1&#10;            tell pop up button 4&#10;                click&#10;                delay 0.1&#10;                if value is &#34;&#8682; Caps Lock&#34; then&#10;                    click menu item 2 of menu 1&#10;                    log &#34;Change Caps Lock&#34;&#10;                else&#10;                    click menu item 1 of menu 1&#10;                    log &#34;Restore Caps Lock&#34;&#10;                end if&#10;            end tell&#10;            click button &#34;OK&#34;&#10;        end tell&#10;    end tell&#10;    quit application &#34;System Preferences&#34;&#10;EOF&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://superuser.com/questions/495956/controlling-modifier-key-behavior-via-the-terminal-on-mac">Controlling modifier key behavior via the terminal on mac</a><br><a href="http://apple.stackexchange.com/questions/103621/run-applescript-from-bash-script">Run AppleScript from bash script</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于命令行爱好者,很多人会选择将黄金键盘位置CapsLock替换成Ctrl,有些人选择仅仅是和默认的Ctrl进行替换，有些人更极端，相当于去掉CapsLock键增加一个Ctrl位置。我选择后者。有时候会想。假如需要输入大段文字的时候一直按住Shift岂不是蛋疼。搜索了下，网
    
    </summary>
    
      <category term="伪技术" scheme="https://www.zoulei.net/categories/%E4%BC%AA%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Docker配置静态博客</title>
    <link href="https://www.zoulei.net/2016/08/21/docker_static_blog/"/>
    <id>https://www.zoulei.net/2016/08/21/docker_static_blog/</id>
    <published>2016-08-21T01:29:29.000Z</published>
    <updated>2016-08-29T13:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先这是篇水文:),仅记录下这2天使用docker的情况。实际上和docker没什么关系,静态博客嘛,生成之后上传到vps然后上面放个nginx就好了，没什么需要操心的</p>
<a id="more"></a>
<p>步骤如下(服务端)：</p>
<ol>
<li>参照docker官方文档安装上docker,最耗时的就是这一步了，因为docker虽然发展几年了，可是还是处于不断完善中。连安装方式都不是简单的<code>apt-get install xx</code>搞定(另外现在docker支持的最低版本号是3.1,意味着openvz是无法使用的，因为openvz的内核版本号是2.6.32，且无法升级)</li>
<li>在你存放静态文件的目录下执行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always -p 80:80 -v `pwd`:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解释一下:</p>
<ul>
<li>d参数表示以detach,以后台进程形式一直运行</li>
<li><code>--restart=always</code>当容器因为异常退出甚至被reboot重启操作后无限自动重启</li>
<li>p参数，用过vagrant的比较好理解，虚拟机都有这么个玩意儿。端口映射</li>
<li>v参数。vagrant也有这个概念。文件夹共享</li>
<li>至于共享的目录,那是因为容器内nginx默认的配置既如此。默认文件位置为/usr/share/nginx/html。这个地方前后的地址必须都是绝对地址。感觉要是能用相对就好了</li>
<li>如果你要去容器内看看它nginx的配置啥的执行(exit退出)<code>docker run -it --restart=always -p 80:80 -v `pwd`:/usr/share/nginx/html nginx /bin/bash</code></li>
</ul>
<p>至于客户端,用rsync同步就好了。我用的是hexo静态博客生成器。使用<a href="https://github.com/hexojs/hexo-deployer-rsync">https://github.com/hexojs/hexo-deployer-rsync</a>这个配合ssh config配置一下就好了。很简单O_o</p>
<p>另外目前本人将这个静态博客放在了3个地方:</p>
<ol>
<li>hostker使用git部署<a href="https://www.zoulei.net">https://www.zoulei.net</a></li>
<li>github pages使用git部署<a href="https://ficapy.github.io">https://ficapy.github.io</a></li>
<li>128M vps rsync同步<a href="https://www.ficapy.com">https://www.ficapy.com</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先这是篇水文:),仅记录下这2天使用docker的情况。实际上和docker没什么关系,静态博客嘛,生成之后上传到vps然后上面放个nginx就好了，没什么需要操心的&lt;/p&gt;
    
    </summary>
    
      <category term="伪技术" scheme="https://www.zoulei.net/categories/%E4%BC%AA%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="https://www.zoulei.net/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>werkzeug源码分析(Debug模块)</title>
    <link href="https://www.zoulei.net/2016/08/07/werkzeug_debug_note/"/>
    <id>https://www.zoulei.net/2016/08/07/werkzeug_debug_note/</id>
    <published>2016-08-07T00:43:31.000Z</published>
    <updated>2016-09-04T07:32:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>flask的debug看起来还是很神奇的，可以在异常页面查看当前调用栈，且能够在当前栈内进行交互式会话用以调试。本文将会从python的REPL进行说明并延伸到flask。看看它的具体实现</p>
<a id="more"></a>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>python的运行是讲源码进行编译，之后虚拟机执行。这2个步骤python都提供了接口,compile和exec。exec的执行会调用compile,我们一般不会主动去调用compile。compile这个函数有三个模式<a href="https://docs.python.org/3/library/functions.html#compile">官方文档</a> <a href="http://stackoverflow.com/questions/2220699/whats-the-difference-between-eval-exec-and-compile-in-python">stackoverflow</a></p>
<ul>
<li>exec:一系列声明</li>
<li>eval:单条表达式</li>
<li>single:单条声明,和exec不同的是当返回不为None的时候执行的时候会打印。这一想都知道专门是为交互式环境准备的</li>
</ul>
<p>编译之后不用说。使用内建函数exec执行就好啦。它带有2个可选参数,全局空间变量及局部空间变量。看一个例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">local = &#123;&#125;</span><br><span class="line">code = compile(<span class="string">'a=1'</span>, filename=<span class="string">'&lt;string&gt;'</span>, mode=<span class="string">'single'</span>)</span><br><span class="line">print(code)</span><br><span class="line">exec(code,local)</span><br><span class="line">code = compile(<span class="string">'a+=1'</span>, filename=<span class="string">'&lt;string&gt;'</span>, mode=<span class="string">'single'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    exec(code)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Error'</span>)</span><br><span class="line">exec(code,local)</span><br><span class="line">print(local.get(<span class="string">'a'</span>))</span><br><span class="line">code = compile(<span class="string">'x+=1'</span>,filename=<span class="string">'&lt;string&gt;'</span>,mode=<span class="string">'single'</span>)</span><br><span class="line">print(code)</span><br><span class="line"><span class="comment"># &lt;code object &lt;module&gt; at 0x10fd9dc90, file "&lt;string&gt;", line 1&gt;</span></span><br><span class="line"><span class="comment"># Error</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># &lt;code object &lt;module&gt; at 0x105c25c90, file "&lt;string&gt;", line 1&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>编译的时候只要语法没有问题就可以通过，看x+=1,即使全局变量不存在x也能够编译通过</li>
<li>使用exec的时候，可以引入一个字典，否则会自动使用默认的global,有了这个字典我们就可以连接上下文，想一想。要是我们执行a=1，如果没有记录。那么后面执行a+=1就会报错了，这肯定不是我们所希望的</li>
</ol>
<h3 id="自带REPL"><a href="#自带REPL" class="headerlink" title="自带REPL"></a>自带REPL</h3><p>要实现一个类似的IDLE环境2条语句就够了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> code</span><br><span class="line">code.interact()</span><br></pre></td></tr></table></figure><br>看调用图<br><img src="http://ficapy.b0.upaiyun.com/blogimg/code_interactiveconsole.png" alt="code_interactiveconsole"><br>会涉及到2个模块，code和codeop，这2个模块可以都说是为生成交互式解释器服务的。code模块作用是接收请求然后解析再执行(exec)。解析部分就是由codeop提供的。设想一下为什么有了compile还需要一个单独的codeop模块。<br>我们使用交互式解释器的时候并不是所有的命令都是一行输入完成的。比如输入一个函数，那就需要多行。将我们输入的多行编译一次。这是我们的需求。codeop就是为这个而存在的。比如你执行codeop.compile_command(‘math(‘)会返回None。这就代表你下一行继续输入，直到你连续输入了2个空行。好了，它知道你输入完成了。核心代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runsource</span><span class="params">(self, source, filename=<span class="string">"&lt;input&gt;"</span>, symbol=<span class="string">"single"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        code = self.compile(source, filename, symbol)</span><br><span class="line">    <span class="keyword">except</span> (OverflowError, SyntaxError, ValueError):</span><br><span class="line">        <span class="comment"># Case 1</span></span><br><span class="line">        self.showsyntaxerror(filename)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> code <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="comment"># Case 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Case 3</span></span><br><span class="line">    self.runcode(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><br>逻辑还是比较好理解的。</p>
<h3 id="Exception-traceback-frame联系"><a href="#Exception-traceback-frame联系" class="headerlink" title="Exception,traceback,frame联系"></a>Exception,traceback,frame联系</h3><p>上个例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomeExcept</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, desc)</span>:</span></span><br><span class="line">        super(CustomeExcept, self).__init__()</span><br><span class="line">        self.desc = desc</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.desc</span><br><span class="line"></span><br><span class="line">    __str__ = __repr__</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">t</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> CustomeExcept(<span class="string">'l'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">app</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    t()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    app()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># traceback.print_exc(file=sys.stdout)</span></span><br><span class="line">    exc_type, exc_value, exc_tb = sys.exc_info()</span><br><span class="line">    print(exc_tb.tb_frame.f_lineno)</span><br><span class="line">    print(exc_type)</span><br><span class="line">    print(exc_value <span class="keyword">is</span> e)</span><br><span class="line">    print(exc_value)</span><br><span class="line">    print([i <span class="keyword">for</span> i <span class="keyword">in</span> dir(exc_tb) <span class="keyword">if</span> <span class="keyword">not</span> i.startswith(<span class="string">'_'</span>)])</span><br><span class="line">    print(exc_tb.tb_frame, exc_tb.tb_lineno, exc_tb.tb_next.tb_lineno, exc_tb.tb_next.tb_next.tb_lineno,</span><br><span class="line">          exc_tb.tb_next.tb_next.tb_next, sys._getframe(<span class="number">0</span>), exc_tb.tb_frame.f_back)</span><br><span class="line">    print(exc_tb.tb_next.tb_frame.f_locals)</span><br><span class="line"><span class="comment"># 23</span></span><br><span class="line"><span class="comment"># &lt;class '__main__.CustomeExcept'&gt;</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># l</span></span><br><span class="line"><span class="comment"># ['tb_frame', 'tb_lasti', 'tb_lineno', 'tb_next']</span></span><br><span class="line"><span class="comment"># &lt;frame object at 0x7f90b5813958&gt; 19 17 13 None &lt;frame object at 0x7f90b5813958&gt; None</span></span><br><span class="line"><span class="comment"># &#123;'a': 1&#125;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>Exception配合raise使用,使用except捕获异常的时候返回它的实例</li>
<li>返回的实例是和帧栈Frame是没有关系的</li>
<li>sys.exc_info返回了异常类，异常实例,traceback实例</li>
<li>traceback对象记录的帧不是当前帧,而是从发起异常的那个函数开始记录帧栈,因此比当前帧栈更长,traceback的中文意思是回溯,它的tb_next可以想象一下,实际上更可以说是读取上一个帧(因为引发异常的那个帧实际上在最上面)</li>
<li>tb_next返回的还是一个traceback对象</li>
<li>traceback模块提供了一些接口(比如traceback.print_exc)从帧中提取出信息然后格式化打印<br>偷一张图(引用自<a href="http://busuncle.github.io/python-vm-and-bytecode.html">http://busuncle.github.io/python-vm-and-bytecode.html</a>)<br><img src="https://ficapy.b0.upaiyun.com/blogimg/pyframeobject_busuncle.github.io.jpg" alt="pyframeobject"></li>
</ul>
<h3 id="werkzeug实现"><a href="#werkzeug实现" class="headerlink" title="werkzeug实现"></a>werkzeug实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__debugger__:yes&#10;cmd:a = 1+1&#10;frm:0&#10;s:3WcibzVj8YXQDR0Na4bv</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://busuncle.github.io/python-vm-and-bytecode.html">Python虚拟机与字节码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;flask的debug看起来还是很神奇的，可以在异常页面查看当前调用栈，且能够在当前栈内进行交互式会话用以调试。本文将会从python的REPL进行说明并延伸到flask。看看它的具体实现&lt;/p&gt;
    
    </summary>
    
      <category term="Flask" scheme="https://www.zoulei.net/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://www.zoulei.net/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>redis-py源码分析</title>
    <link href="https://www.zoulei.net/2016/08/06/redis_py_note/"/>
    <id>https://www.zoulei.net/2016/08/06/redis_py_note/</id>
    <published>2016-08-06T11:39:07.000Z</published>
    <updated>2016-08-06T23:04:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文会简述该库的代码组织架构，会着重介绍它实现的连接池ConnectPool以及如何实现的线程、进程安全。</p>
<a id="more"></a>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#10;&#9500;&#9472;&#9472; __init__.py&#10;&#9500;&#9472;&#9472; _compat.py          &#20860;&#23481;&#24615;&#10;&#9500;&#9472;&#9472; client.py           &#23454;&#29616;&#23458;&#25143;&#31471;,&#35843;&#29992;connectionpool&#10;&#9500;&#9472;&#9472; connection.py       &#23454;&#29616;&#36830;&#25509;&#27744;&#65292;&#36830;&#25509;&#65292;&#35299;&#26512;&#22120;&#10;&#9500;&#9472;&#9472; exceptions.py       &#24322;&#24120;&#31867;&#10;&#9500;&#9472;&#9472; lock.py             &#23454;&#29616;&#20998;&#24067;&#24335;&#38145;&#10;&#9500;&#9472;&#9472; sentinel.py         &#37197;&#21512;redis sentinel&#26426;&#21046;&#23454;&#29616;&#39640;&#21487;&#29992;&#23458;&#25143;&#31471;&#10;&#9492;&#9472;&#9472; utils.py            &#36741;&#21161;&#31867;</span><br></pre></td></tr></table></figure>
<h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">r = redis.Redis()</span><br><span class="line">r.set(<span class="string">'foob'</span>, <span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure>
<p>看架构图<br><img src="https://ficapy.b0.upaiyun.com/blogimg/redis_py_arch.png" alt="redis_client_arch"><br>看调用图(以下为5年前的<a href="https://github.com/andymccurdy/redis-py/tree/2.4">2.4版本</a>)<br><img src="https://ficapy.b0.upaiyun.com/blogimg/redis_old_version.png" alt="redis_old_version"><br>第一步执行<code>r=redis.Redis()</code>没进行什么操作，同时隐式的初始化了ConnectionPool。<br>等到执行set操作的时候。就是执行了execute_command，此时分为了几个步骤。看第5个函数调用，从连接池里面get_connection。如果没有可用的，那么则新建(redis.connection.Connection.<strong>init</strong>),此时并没有创建socket连接。第8个函数调用send_command,命令打包然后创建连接发送。该版本使用connection._sock.makefile(‘r’)便于读取。<br>再到了第21个函数调用Connection.read_response.使用解析器从socket读取数据并转换成便于python使用的数据结构<br>最后finally将该连接释放到线程池</p>
<p>现在可以看到有这样一条关系，每一个redis.Redis()实例都有一个ConnectionPool对象,一个连接池至少含有一条连接。所以绝大多数情况没有必要写出连接池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool = redis.ConnectionPool()&#10;r = redis.Redis(connection_pool=pool)&#10;&#31561;&#20215;&#20110;&#10;r = redis.Redis()</span><br></pre></td></tr></table></figure></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>如果你的程序是单线程的。那么没什么好说的，一个Redis实例，一个连接池，一个socket连接。<br>多线程那我们主要考虑的是线程安全问题。对于redis客户端就是socket连接绝对要线程间隔离，否则一个线程解析了另外一个socket的返回内容，那么多线程也就没意义了。测试一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">r = redis.Redis()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    r.setex(threading.get_ident(), threading.get_ident(), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">assert</span> r.get(threading.get_ident()) <span class="keyword">in</span> [str(threading.get_ident()).encode(), <span class="keyword">None</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    threading.Thread(target=main).start()</span><br><span class="line"><span class="comment"># watch -n 1 "redis-cli INFO clients"    </span></span><br><span class="line"><span class="comment"># Every 1.0s: redis-cli INFO clients                                           Sat Aug  6 21:34:31 2016</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># #Clients</span></span><br><span class="line"><span class="comment"># connected_clients:26</span></span><br><span class="line"><span class="comment"># client_longest_output_list:0</span></span><br><span class="line"><span class="comment"># client_biggest_input_buf:0</span></span><br><span class="line"><span class="comment"># blocked_clients:0</span></span><br></pre></td></tr></table></figure><br>可以看到结果并没有错误，而且创建的连接数和创建的线程数并不是一致的</p>
<p>试想一下，每次执行一次类似set的指令。都会从连接池(List结构)取出(pop)一个连接。而list.pop是线程安全的。执行完毕命令后又会使用append加入到连接池，list.append也是线程安全的。所以针对socket的操作是线程隔离的。这一切好像和_in_use_connections并没有什么关系。对于一个简单的连接池。从连接池取出，用完加入到连接池。而_in_use_connections记录的是使用中的线程。啥子用呢。它用于一个接口(关闭连接池中的所有连接)。注意关闭连接并不会将_available_connections和_in_use_connections清空。它只会将connection对象中的_sock设置为None，而每次执行命令的时候connection都是会检查_sock是否为空，如果为空则会重新建立连接,如下示例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">r = redis.Redis()</span><br><span class="line">r.setex(<span class="string">'key'</span>, <span class="string">'value'</span>, <span class="number">20</span>)</span><br><span class="line">print(r.connection_pool._available_connections[<span class="number">0</span>]._sock)</span><br><span class="line">r.connection_pool.disconnect()</span><br><span class="line">print(r.connection_pool._available_connections[<span class="number">0</span>]._sock)</span><br><span class="line">r.setex(<span class="string">'key'</span>,<span class="string">'value'</span>,<span class="number">20</span>)</span><br><span class="line">print(r.connection_pool._available_connections[<span class="number">0</span>]._sock)</span><br><span class="line"><span class="comment"># &lt;socket.socket fd=5, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6, laddr=('::1', 62900, 0, 0), raddr=('::1', 6379, 0, 0)&gt;</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># &lt;socket.socket fd=5, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6, laddr=('::1', 62901, 0, 0), raddr=('::1', 6379, 0, 0)&gt;</span></span><br></pre></td></tr></table></figure><br>因为它关闭连接的时候并没有将对应的connection对象从连接池中删除。那么会造成一个问题。如果你创建过100个连接，那么连接池将会一直复用这些对象。如果你高峰期创建过多的连接，而后又只需要几个连接就够了(虽然这样的问题估计极少会遇到)。你可以显式的pop出_available_connections并关闭。<br>其实有一个地方是非线程安全的。在创建连接的时候有self._created_connections += 1,如果你访问这个值得到创建的连接数是不可靠的。不过这都无关紧要，因为你不可能在极短的时间内创建许多连接。即使这里不准。统计误差也不会有2个。</p>
<p>为了避免无端创建出N多连接。该客户端后期加入了BlockingConnectionPool类。使用LifoQueue创建出连接队列，如果该队列被使用完，那么后续请求将会阻塞一段时间，过长则引发异常。</p>
<h3 id="多进程安全"><a href="#多进程安全" class="headerlink" title="多进程安全"></a>多进程安全</h3><p>redis-py在2.4.12加入了多线程安全<a href="https://github.com/andymccurdy/redis-py/issues/234">见issues</a>。<br>可以看到实现原理也是很简单的。fork进程的时候socket一样使用的。为了分开，使用了os.getpid()区分。如果进程号变了，则关闭所有的连接，重新连接后自然就分开了。同时为了防止一个进程有多个线程这种情况。一个线程关闭后，另外一个线程也可能执行关闭操作。所以此处使用了锁<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_checkpid</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.pid != os.getpid():</span><br><span class="line">        <span class="keyword">with</span> self._check_lock:</span><br><span class="line">            <span class="keyword">if</span> self.pid == os.getpid():</span><br><span class="line">                <span class="comment"># another thread already did the work while we waited</span></span><br><span class="line">                <span class="comment"># on the lock.</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.disconnect()</span><br><span class="line">            self.reset()</span><br></pre></td></tr></table></figure></p>
<p>插播一下当前2.10.5版本的调用图<br><img src="http://ficapy.b0.upaiyun.com/blogimg/redis_pool.png" alt="new_redis_pool"><br>可以看到和最上面的调用图出入很小，仅仅加入了进程安全,将socket.makefile变成了SocketBuffer.</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>线程锁就是多线程间有线程间共享变量。进程锁就是多进程间有进程间共享变量。此处的共享变量就是将变量存储到redis数据库。实现也比较简单。截取一段acquire看看<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_acquire</span><span class="params">(self, token)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.redis.setnx(self.name, token):</span><br><span class="line">        <span class="keyword">if</span> self.timeout:</span><br><span class="line">            <span class="comment"># convert to milliseconds</span></span><br><span class="line">            timeout = int(self.timeout * <span class="number">1000</span>)</span><br><span class="line">            self.redis.pexpire(self.name, timeout)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><br>另外它实现的只是最简单的锁。比如可重入锁啥的都是没有实现的。如果你想配合sentinel进行高可用。往下看…..</p>
<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p><img src="https://ficapy.b0.upaiyun.com/blogimg/redis_sentinel.png" alt="redis_sentinel"><br>得益于redis-py的松耦合，连接池、连接、解析器基本都很独立。<br>客户端和监视器组创建一个上面说的Redis正常连接。它主要提供接口返回master的地址和返回salve的地址。<br>然后我们使用master_for返回的也是一个Redis连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return redis_class(connection_pool=connection_pool_class(&#10;            service_name, self, **connection_kwargs))</span><br></pre></td></tr></table></figure></p>
<p>不过它进行对连接池和连接对象都进行了一些修改。可以看到它将self传递给了底层连接池。而连接池也使用<code>self.connection_kwargs[&#39;connection_pool&#39;] = weakref.proxy(self)</code>将自己传递给了底层Connection，就这样它实现了高可用客户端，在底层连接的时候使用高层提供的函数提供正确的地址~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文会简述该库的代码组织架构，会着重介绍它实现的连接池ConnectPool以及如何实现的线程、进程安全。&lt;/p&gt;
    
    </summary>
    
      <category term="源码解析" scheme="https://www.zoulei.net/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="python" scheme="https://www.zoulei.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>werkzeug源码分析(local.py)</title>
    <link href="https://www.zoulei.net/2016/08/03/werkzeug_local_note/"/>
    <id>https://www.zoulei.net/2016/08/03/werkzeug_local_note/</id>
    <published>2016-08-03T00:58:00.000Z</published>
    <updated>2016-09-04T08:14:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>有人说flask的上下文机制是整个框架的精华部分，有人说它神奇的g让人费解。werkzeug的local.py就是它的具体实现。这个看似神奇的机制背后加上应用代码也不过两三百行。不过好像坑还是<code>比较深</code>的。另外flask的0.1版本才200多行代码。值得瞅一下</p>
<a id="more"></a>
<h3 id="直观感受上下文"><a href="#直观感受上下文" class="headerlink" title="直观感受上下文"></a>直观感受上下文</h3><p>使用wrk进行压测<code>wrk -t300 -c300 -d10s http://127.0.0.1:5000</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask.globals <span class="keyword">import</span> _request_ctx_stack,_app_ctx_stack</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="decorator">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    pprint(_request_ctx_stack._local.__storage__)</span><br><span class="line">    pprint(_app_ctx_stack._local.__storage__)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line">app.run(threaded=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 某一时刻状态</span></span><br><span class="line"><span class="comment"># &#123;123145360109568: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145391640576: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145407406080: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145417916416: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145428426752: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145459957760: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145480978432: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145496743936: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145512509440: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145538785280: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145549295616: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145601847296: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145638633472: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145680674816: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145743736832: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145764757504: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;&#125;</span></span><br><span class="line"><span class="comment"># &#123;123145360109568: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x103f90f60&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145391640576: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x103fcdc50&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145407406080: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x10402c080&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145417916416: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x103fa0668&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145428426752: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x104058828&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145459957760: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x103fd8470&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145480978432: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x1040859e8&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145496743936: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x104078cf8&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145512509440: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x104036c88&gt;]&#125;,</span></span><br></pre></td></tr></table></figure></p>
<h3 id="为什么会有Local"><a href="#为什么会有Local" class="headerlink" title="为什么会有Local"></a>为什么会有Local</h3><p>比较抽象的解释叫它<code>线程内共享变量</code>，下面来个例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">l = threading.local()</span><br><span class="line">l.a = <span class="number">1</span></span><br><span class="line">threading.Thread(target=<span class="keyword">lambda</span>: setattr(l, <span class="string">'a'</span>, <span class="number">2</span>) <span class="keyword">or</span> print(l.a, threading.current_thread())).start()</span><br><span class="line">print(l.a)</span><br><span class="line"><span class="comment"># 2 &lt;Thread(Thread-1, started 123145307557888)&gt;</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure><br>可以看出就是一全局对象对它设置的属性在线程间是隔离的。可是这又有什么用。我们作为框架使用者逻辑一般都是写在一起的，没有人会故意去像这样写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = threading.local()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    l.a = <span class="number">1</span></span><br><span class="line">    l.a  <span class="comment">##进行引用</span></span><br></pre></td></tr></table></figure><br>可是我们使用的是框架！线程的调起不是我们主动去操作的。框架会有一些第三方扩展。它们依靠此机制给我们提供接口，比如来个<a href="http://flask.pocoo.org/docs/0.11/appcontext/#context-usage">官方示例</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> g</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_db</span><span class="params">()</span>:</span></span><br><span class="line">    db = getattr(g, <span class="string">'_database'</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">if</span> db <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        db = g._database = connect_to_database()</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line"><span class="comment">#=========================</span></span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalProxy</span><br><span class="line">db = LocalProxy(get_db)</span><br></pre></td></tr></table></figure></p>
<p>Local的实现原理很简单，这里不详述了。就是前一篇博文说的字典的<code>dict[key] = value</code>是线程安全的。其实threading.local也是一样的作用，那么为什么不用它。</p>
<ul>
<li>支持了greenlet(本博文只会涉及到多线程情况)</li>
<li>自带的写法太特么恶心了，那个源码我都快看吐了，不如自己写一个(我都没看透自带的为什么要那么写,如果你能轻松看明白，那么你肯定是看魔术方法的大神)<br>简述下自带的逻辑，主要是这几句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># python2.7.11&#20195;&#30721;&#10;dict = object.__getattribute__(self, &#39;__dict__&#39;)&#10;current_thread().__dict__[key] = dict&#10;&#10;key = object.__getattribute__(self, &#39;_local__key&#39;)&#10;d = current_thread().__dict__.get(key)&#10;# import threading&#10;# l = threading.current_thread()&#10;# print(l is threading.current_thread())&#10;# threading.Thread(target=lambda :print(threading.current_thread() is l)).start()&#10;# True&#10;# False</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在同一线程内threading.current_thread()是同一对象，有一个_patch函数，该函数在local属性被调用前提前调用，将current_thread().__dict__相关的内容绑定在local.__dict__上。</p>
<h3 id="为什么会有LocalStack"><a href="#为什么会有LocalStack" class="headerlink" title="为什么会有LocalStack"></a>为什么会有LocalStack</h3><p>它主要将上面的Local由<code>l.key = value</code>变成了<code>l.push(value)</code>。变成了栈结构。可是从上面的直观感受上下文部分可以看到在多线程环境下任一时刻栈里面都仅有一个内容。那么还为什么要使用栈呢，往下看。</p>
<h3 id="为什么会有LocalProxy"><a href="#为什么会有LocalProxy" class="headerlink" title="为什么会有LocalProxy"></a>为什么会有LocalProxy</h3><p>从名字就可以看出来是代理模式。可以看看github上的<a href="https://github.com/faif/python-patterns/blob/master/proxy.py">设计模式</a>，同样是讲的代理模式，flask的实际应用就比这个例子要高明的多</p>
<p>我们使用代理是为了绕过防火墙访问外面的世界，那么LocalProxy这个代理是干啥子的呢。设想一下。我们使用了l = Local()并且在上面给一个属性赋值了l.key = value。那么当你要调用的时候就使用l.key就好啦。现在我们没有直接用Local用的是l = LocalStack(),l.push(RequestContext()),request这个属性又在<br>RequestContext()这个对象上。那么我们要访问request怎么办！此时你就要执行l.top.request进行访问。可是优雅呢！优雅呢！优雅呢！优雅哪里去了。我们很懒，我们想执行一个request就能代替l.top.request(有人会问为什么不直接写死reques = l.top.request，那是因为它是死！！！的,而l.top.request是随着线程进入退出一直出入栈动态变化的，我们只能在每次使用的时候执行l.top.request得到正确的结果)。→_→这就是这个代理能为我们做的<br>执行repr(current_app)的调用图，请无视pycall那一块<br><img src="http://ficapy.b0.upaiyun.com/blogimg/werkzeug_localproxy.png" alt="werkzeug_localproxy"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_app</span><span class="params">()</span>:</span></span><br><span class="line">    top = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_app_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> top.app</span><br><span class="line"></span><br><span class="line">_app_ctx_stack = LocalStack()</span><br><span class="line">current_app = LocalProxy(_find_app)</span><br></pre></td></tr></table></figure><br>在LocalProxy里面我们写了一个回调函数，当对LocalProxy属性进行访问的时候，它永远都是先执行_get_current_object,该函数就是执行我们写入的回调函数得到访问对象,比如current_app就是得到_app_ctx_stack.top.app对象。最后再对得到的对象进行属性访问</p>
<p>对LocalProxy讲3个小细节</p>
<ol>
<li><p>__init__中有<code>object.__setattr__(self, &#39;_LocalProxy__local&#39;, local)</code>。如果你要确保对一个对象的<code>__dict__</code>中加入内容，需要使用object.__setattr__，使用self.x、setattr(self,’x’)、self.__dict__[x]都是不确定的，因为它self这个对象可能会重写自身的__setattr__,其次对于私有变量。执行__setattr__的时候需要变换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Foo():&#10;    def __init__(self):&#10;        self.__a = 1&#10;print(Foo().__dict__)&#10;# &#123;&#39;_Foo__a&#39;: 1&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最下面同时也对所有可列举的魔术方法进行了代理<code>__str__ = lambda x:    str(x._get_current_object())</code></p>
</li>
<li>由于代理的存在原始对象的访问需要通过_get_current_object(其实对于看过代码的这应该是废话O_o)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask,current_app&#10;from flask.globals import _app_ctx_stack&#10;with Flask(__name__).app_context():&#10;    print(current_app is _app_ctx_stack.top.app)&#10;    print(current_app._get_current_object() is _app_ctx_stack.top.app)&#10;# False&#10;# True</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="request、session和g"><a href="#request、session和g" class="headerlink" title="request、session和g"></a>request、session和g</h3><p>这几个和上下文息息相关,比如离开了对应的上下文它们完全无法使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request, session, g</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [request, session, g]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> RuntimeError:</span><br><span class="line">        print(<span class="string">'boom! '</span>, end=<span class="string">''</span>)</span><br><span class="line"><span class="comment"># boom! boom! boom!</span></span><br></pre></td></tr></table></figure><br>flask的0.1版本是只有RequestContext请求上下文，没有应用上下文的。<a href="https://github.com/pallets/flask/commit/47288231fe8f9c6b2c413d50160c32c3884d5785">直到0.9版本才用二三十行代码加上AppContext应用上下文</a><br>为什么要加上应用上下文呢。官方文档我没有找到很详尽的解释，<a href="http://flask.pocoo.org/docs/0.11/appcontext/#purpose-of-the-application-context">只有一段简要的描述</a>，同时参考了下别人的博客。我个人理解是为了处理单独使用应用上下文不使用请求上下文的情况。另外文档有<code>creating such a request context is an unnecessarily expensive operation</code>在某些情况使用请求上下文是昂贵的没有必要的操作。参考下面的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,current_app</span><br><span class="line"><span class="keyword">from</span> flask.globals <span class="keyword">import</span> _app_ctx_stack, _request_ctx_stack</span><br><span class="line"></span><br><span class="line">app1 = Flask(<span class="string">'a'</span>)</span><br><span class="line">app2 = Flask(<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> app1.app_context():</span><br><span class="line">    <span class="keyword">with</span> app2.app_context():</span><br><span class="line">        print(_request_ctx_stack._local.__storage__)</span><br><span class="line">        print(_app_ctx_stack._local.__storage__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line"><span class="comment"># &#123;140735191154688: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x1096c1f60&gt;, &lt;flask.ctx.AppContext object at 0x1096cd048&gt;]&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> app1.test_client() <span class="keyword">as</span> client1:</span><br><span class="line">    <span class="keyword">with</span> app2.test_client() <span class="keyword">as</span> client2:</span><br><span class="line">        print(_request_ctx_stack._local.__storage__)</span><br><span class="line">        print(_app_ctx_stack._local.__storage__)</span><br><span class="line">        client2.get(<span class="string">'/b'</span>)</span><br><span class="line">        print(current_app)</span><br><span class="line">        print(_request_ctx_stack._local.__storage__)</span><br><span class="line">        client1.get(<span class="string">'/a'</span>)</span><br><span class="line">        print(current_app)</span><br><span class="line">        print(_request_ctx_stack._local.__storage__)</span><br><span class="line">    resp = client1.get(<span class="string">'/a'</span>)</span><br><span class="line">    print(_request_ctx_stack._local.__storage__)</span><br><span class="line">    print(current_app)</span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line"><span class="comment"># &lt;Flask 'b'&gt;</span></span><br><span class="line"><span class="comment"># &#123;140735191154688: &#123;'stack': [&lt;RequestContext 'http://localhost/b' [GET] of b&gt;]&#125;&#125;</span></span><br><span class="line"><span class="comment"># &lt;Flask 'a'&gt;</span></span><br><span class="line"><span class="comment"># &#123;140735191154688: &#123;'stack': [&lt;RequestContext 'http://localhost/a' [GET] of a&gt;]&#125;&#125;</span></span><br><span class="line"><span class="comment"># &#123;140735191154688: &#123;'stack': [&lt;RequestContext 'http://localhost/a' [GET] of a&gt;]&#125;&#125;</span></span><br></pre></td></tr></table></figure><br>首先可以看到执行app_context()的时候有了应用上下文，和请求上下文一毛钱关系都没有。看下代码就是return AppContext(self),它自己有个<strong>enter</strong>函数执行了push。这有什么用呢。比如你要在命令行调用下你写的数据库函数。很明显它需要数据库的配置app.config。如果没有应用上下文，那么你需要先创建请求上下文。现在你只需要创建应用上下文了(比请求上下文更轻量)。再者当我们一次性进入了多个应用上下文的时候此时栈里面就不止一个元素了。所以。。。。这也是上面问的为什么要用栈</p>
<p>第二个例子只有当请求发送后应用上下文和请求上下文才会同时入栈。且同时出栈，所以网上有博客写一个应用上下文会包含多个请求上下文这是不对的。并且绝对不能理解为应用上下文的生存周期是一个app从启动到关闭这个过程</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.tonyseek.com/post/the-context-mechanism-of-flask/">Flask 的 Context 机制</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有人说flask的上下文机制是整个框架的精华部分，有人说它神奇的g让人费解。werkzeug的local.py就是它的具体实现。这个看似神奇的机制背后加上应用代码也不过两三百行。不过好像坑还是&lt;code&gt;比较深&lt;/code&gt;的。另外flask的0.1版本才200多行代码。值得瞅一下&lt;/p&gt;
    
    </summary>
    
      <category term="Flask" scheme="https://www.zoulei.net/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://www.zoulei.net/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>list和dict的线程安全</title>
    <link href="https://www.zoulei.net/2016/07/31/list_dict_threading_safe/"/>
    <id>https://www.zoulei.net/2016/07/31/list_dict_threading_safe/</id>
    <published>2016-07-30T23:47:09.000Z</published>
    <updated>2016-08-02T03:56:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚转行第一次IT面试的时候面试官问我，list和dict是不是线程安全的。当时我就想，擦嘞,作为一个初学者list和dict不是线程安全的都看了N遍啦。这还有疑问么~~~，现在想想并没有抓住重点，线程安全应该针对于具体的操作，而不是具体的对象，我们说Queue是线程安全的是因为针对它的所有操作都是线程安全的。</p>
<a id="more"></a>
<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="https://docs.python.org/2/faq/library.html#what-kinds-of-global-value-mutation-are-thread-safe">官方文档</a></h3><p>可以看到大概有这么个概念<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L,L1,L2-&#62;list&#10;D,D1,D2-&#62;dict&#10;x,y-&#62;object&#10;i,j-&#62;int&#10;&#10;&#32447;&#31243;&#23433;&#20840;&#10;L.append(x)&#10;L1.append(L2)&#10;x=L[i]&#10;y=L.pop()&#10;L1[i,j]=L2&#10;L.sort()&#10;x=y&#10;x.field=y&#10;D[x]=y&#10;D1.update(D2)&#10;D.keys()&#10;&#10;&#10;&#20197;&#19979;&#26159;&#38750;&#32447;&#31243;&#23433;&#20840;&#10;i=i+1&#10;L.append(L[-1])&#10;L[i]=L[j]&#10;D[x]=D[x]+1</span><br></pre></td></tr></table></figure><br>可以看到list的append啥的其实是线程安全的。我们看到的举非线程安全的例子基本都是i+=1这种，最后得到的结果小于相加次数。然后最后说一句多线程对同一资源进行操作的时候要加锁哇。。。。。这话直接说的好像比较不负责任。让我这样的初学者风声鹤唳草木皆兵</p>
<h3 id="一点小解释"><a href="#一点小解释" class="headerlink" title="一点小解释"></a>一点小解释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> i</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3000000</span>):</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">th = [threading.Thread(target=main), threading.Thread(target=main)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> th:</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> th:</span><br><span class="line">    t.join()</span><br><span class="line">print(i)</span><br><span class="line"></span><br><span class="line">dis.dis(main)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4372439</span></span><br><span class="line"><span class="comment">#   8           0 SETUP_LOOP              30 (to 33)</span></span><br><span class="line"><span class="comment">#               3 LOAD_GLOBAL              0 (range)</span></span><br><span class="line"><span class="comment">#               6 LOAD_CONST               1 (3000000)</span></span><br><span class="line"><span class="comment">#               9 CALL_FUNCTION            1</span></span><br><span class="line"><span class="comment">#              12 GET_ITER            </span></span><br><span class="line"><span class="comment">#         &gt;&gt;   13 FOR_ITER                16 (to 32)</span></span><br><span class="line"><span class="comment">#              16 STORE_FAST               0 (_)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#   9          19 LOAD_GLOBAL              1 (i)</span></span><br><span class="line"><span class="comment">#              22 LOAD_CONST               2 (1)</span></span><br><span class="line"><span class="comment">#              25 INPLACE_ADD         </span></span><br><span class="line"><span class="comment">#              26 STORE_GLOBAL             1 (i)</span></span><br><span class="line"><span class="comment">#              29 JUMP_ABSOLUTE           13</span></span><br><span class="line"><span class="comment">#         &gt;&gt;   32 POP_BLOCK           </span></span><br><span class="line"><span class="comment">#         &gt;&gt;   33 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="comment">#              36 RETURN_VALUE</span></span><br></pre></td></tr></table></figure>
<p>我们知道python代码经过编译成字节码指令，然后python虚拟机按照指令进行执行，这里每一条指令都是原子操作不会被中断，可以看到<code>i+=1</code>这条语句被划分为4条指令被执行。取出i变量的值入栈→→将被加数1入栈→→取出2个数相加结果再入栈→→结果出栈。因为是要累加。我们当然需要累加的第一步加入的值是上一个累加的结果。可是在多线程不加锁的情况下每一条指令被执行完毕后都有可能去执行另外一个线程的指令。这就会造成第一步加入的值有可能和另外一个线程是一样的，于是悲剧发生了O_o</p>
<p>再想一想append<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8          19 LOAD_GLOBAL              1 (i)&#10;           22 LOAD_ATTR                2 (append)&#10;           25 LOAD_CONST               2 (1)&#10;           28 CALL_FUNCTION            1&#10;           31 POP_TOP</span><br></pre></td></tr></table></figure><br> <a href="http://jakevdp.github.io/images/array_vs_list.png">图片引用自</a><br> <img src="https://ficapy.b0.upaiyun.com/blogimg/array_vs_list.png" alt="array_vs_list"><br>可以看出list就是一个容器.append就相当与在最后面加了一个引用。虽然它也是由几条指定组成。也会发生交错执行的情况。这种交错造成的结果无非就是我本来是先执行的却在了一个的后面执行了插入，造成的结果就是<code>顺序错乱了</code>。😄可是特喵本来就是多线程程序，谁特喵会去关心顺序呢。所以就说线程安全了。<br>可以看出，append和<code>i+=1</code>最大的区别就是是否对自身进行了修改。dict同理~~</p>
<p>另外加锁的时间开销其实还是挺大的。上例，我用3个线程(结果是9000000)，不加锁1.38秒，加锁执行39.16秒(python2.7.11)。不加锁1.06秒，加锁3.94秒(python3.5.1)。→_→当然你可以把i+=1改成i.apped(1)这样不用锁结果也能对了，只不过内存消耗感人</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://qingyunha.github.io/taotao/">A Python Interpreter Written in Python</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚转行第一次IT面试的时候面试官问我，list和dict是不是线程安全的。当时我就想，擦嘞,作为一个初学者list和dict不是线程安全的都看了N遍啦。这还有疑问么~~~，现在想想并没有抓住重点，线程安全应该针对于具体的操作，而不是具体的对象，我们说Queue是线程安全的是因为针对它的所有操作都是线程安全的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://www.zoulei.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>werkzeug源码分析(Request/Response和热重启)</title>
    <link href="https://www.zoulei.net/2016/07/25/werkzeug_note_requests_response_auto_realod/"/>
    <id>https://www.zoulei.net/2016/07/25/werkzeug_note_requests_response_auto_realod/</id>
    <published>2016-07-25T13:48:17.000Z</published>
    <updated>2016-09-04T08:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Flask这个人人称赞的微框架就是构建在werkzeug之上，werkzeug给自己的定位就是工具集合。它实现了wsgi server、Requests/Response封装、DEBUG、热重启、路由控制以及其他的一些辅助功能。接下来的几篇文章会从一些大的方面去分析它。本篇如标题:D</p>
<a id="more"></a>
<h3 id="WSGI-Server"><a href="#WSGI-Server" class="headerlink" title="WSGI Server"></a>WSGI Server</h3><p>这个初略说一下。和它相关的代码不多。和wsgiref一样它构建在python自带模块SocketServer和BaseHTTPRequestHandler之上。甚至比自带的wsgiref代码要少。它主要增加了SSL和socket.fromfd支持。并且将debug、静态文件分发、热重启组合再了一起</p>
<h3 id="Request、Response封装"><a href="#Request、Response封装" class="headerlink" title="Request、Response封装"></a>Request、Response封装</h3><p>这个可能算是重点了。有个库webob就是专门做这个的。占得代码量也很大。可惜我并不想详细写每一个的过程，太麻烦了，了解了大概就好啦。以后会主要分析下datastructures.py这个文件。下面是超简洁的原理代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, env)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="decorator">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(cls, f)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(env, start_response)</span>:</span></span><br><span class="line">            request = cls(env)</span><br><span class="line">            <span class="keyword">return</span> f(request)(env, start_response)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        self.body = str</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, env, start_response)</span>:</span></span><br><span class="line">        start_response(<span class="string">'200 OK'</span>, [])</span><br><span class="line">        <span class="keyword">return</span> [self.body]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="decorator">@Request.application</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">app</span><span class="params">(req)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Response(<span class="string">b'Hello'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line">make_server(<span class="string">''</span>, <span class="number">8000</span>, app).serve_forever()</span><br></pre></td></tr></table></figure><br>可以大概了解是这么回事:</p>
<ul>
<li>Request它主要封装的是headers，然后嘞，各种属性都用property就好了，剩下的body和其他的也差不多啦。</li>
<li>Request.application这个装饰器的作用就是将原来的env,start_response参数变成req给我们使用</li>
<li><code>Response它就是一个wsgiapp对象</code><br>看下它们2个的继承图<br><img src="https://ficapy.b0.upaiyun.com/blogimg/werkzerg_wrappers_inherit.png" alt="werkzeug.wrappers.inherit"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlainRequest</span><span class="params">(StreamOnlyMixin, Request)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span><span class="params">(BaseResponse, ETagResponseMixin, ResponseStreamMixin,</span><br><span class="line">               CommonResponseDescriptorsMixin,</span><br><span class="line">               WWWAuthenticateMixin)</span>:</span></span><br></pre></td></tr></table></figure>
翻源码可以看到它们的继承大部分都是对headers的操作</li>
</ul>
<h3 id="热重启实现原理"><a href="#热重启实现原理" class="headerlink" title="热重启实现原理"></a>热重启实现原理</h3><p>上简图：<br><img src="https://ficapy.b0.upaiyun.com/blogimg/werkzeug_autoreload.png" alt="werkzeug_autoreload"><br>上原理代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_change</span><span class="params">()</span>:</span></span><br><span class="line">    mtimes = &#123;&#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        filename = __file__</span><br><span class="line">        mtime = os.stat(filename).st_mtime</span><br><span class="line">        old_time = mtimes.get(filename)</span><br><span class="line">        <span class="keyword">if</span> old_time <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            mtimes[filename] = mtime</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> mtime &gt; old_time:</span><br><span class="line">            print(<span class="string">' * Detected change in &#123;&#125;, reloading'</span>.format(filename))</span><br><span class="line">            sys.exit(<span class="number">3</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.environ.get(<span class="string">'secord_process'</span>):</span><br><span class="line">    threading.Thread(target=main, args=()).start()</span><br><span class="line">    file_change()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        env = os.environ.copy()</span><br><span class="line">        env[<span class="string">'secord_process'</span>] = <span class="string">'true'</span></span><br><span class="line">        exit_code = subprocess.call([sys.executable] + sys.argv, env=env)</span><br><span class="line">        <span class="keyword">if</span> exit_code != <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p>做法就是主线程啥事没做，跑一个死循环，生成子进程(就相当运行自身,区别就是os.environ)。这个进程内使用单独的线程跑需要运行的函数，另外就是检查相关文件是否被改变。改变就执行sys.exit。然后就又被主线程的死循环生成了新的子进程</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask这个人人称赞的微框架就是构建在werkzeug之上，werkzeug给自己的定位就是工具集合。它实现了wsgi server、Requests/Response封装、DEBUG、热重启、路由控制以及其他的一些辅助功能。接下来的几篇文章会从一些大的方面去分析它。本篇如标题:D&lt;/p&gt;
    
    </summary>
    
      <category term="Flask" scheme="https://www.zoulei.net/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://www.zoulei.net/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>osx airdrop无法使用修复</title>
    <link href="https://www.zoulei.net/2016/07/23/fix_osx_airdrop_not_working/"/>
    <id>https://www.zoulei.net/2016/07/23/fix_osx_airdrop_not_working/</id>
    <published>2016-07-23T02:53:25.000Z</published>
    <updated>2016-07-24T08:27:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>前些天用的好好的airdrop居然无法使用了。具体情况是：我有iphone、ipad、mac。iphone和ipad能够互相发现。mac对它们2个发现不了。妈蛋正要传资料可急死我了。网上一搜这种情况还不在少数。</p>
<p>遇到这种情况。可以打开about this mac→→system report查看Network(wifi)可以看到Country Code:是不是CN(我电脑有问题的时候是X3)。如果不是，那么无法使用airdrop就和它有关。至于如何修复这个问题我没有找到确切的办法.有一个原因可能是由于路由器造成的。这个可以打开系统自带的无线检测工具Wireless Diagnostics(Windows→→scan)查看是不是由于国家码冲突造成的(详情看第一个参考资料)。如果这里没有问题(我的不是这个问题)。。。。。那么请尝试执行以下操作</p>
<ol>
<li>将操作系统的语言改成中文</li>
<li>在系统设置页退出icloud账号</li>
<li>重启系统<br>：<br>：<br>尼玛，有可能就暂时能正常使用了ヾ(｡｀Д´｡)</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.howtogeek.com/211993/how-to-fix-conflicting-country-codes-and-improve-your-macs-wi-fi/">how-to-fix-conflicting-country-codes-and-improve-your-macs-wi-fi</a><br><a href="http://km.nicetypo.com/doc/7090786787135be8d32fa6624b892309">解決無法從 iPhone AirDrop 到 Mac 的方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些天用的好好的airdrop居然无法使用了。具体情况是：我有iphone、ipad、mac。iphone和ipad能够互相发现。mac对它们2个发现不了。妈蛋正要传资料可急死我了。网上一搜这种情况还不在少数。&lt;/p&gt;
&lt;p&gt;遇到这种情况。可以打开about this ma
    
    </summary>
    
    
      <category term="随笔" scheme="https://www.zoulei.net/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>pycallgraph源码分析</title>
    <link href="https://www.zoulei.net/2016/07/22/pycallgraph_note/"/>
    <id>https://www.zoulei.net/2016/07/22/pycallgraph_note/</id>
    <published>2016-07-22T07:13:05.000Z</published>
    <updated>2016-08-18T10:01:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>用来生成函数调用图，这个工具可能名气比较大。因为看介绍就能看到好像可以生成比较帅气的图像。从源码层面看。其实这个工具是相当简单的，就是使用了sys.settrace接口,该接口常用于debug、profile(本文环境python3.5.1)。</p>
<a id="more"></a>
<h3 id="pycallgraph文件结构"><a href="#pycallgraph文件结构" class="headerlink" title="pycallgraph文件结构"></a>pycallgraph文件结构</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#10;&#9500;&#9472;&#9472; __init__.py&#10;&#9500;&#9472;&#9472; color.py                &#26174;&#31034;&#39068;&#33394;&#10;&#9500;&#9472;&#9472; config.py               &#20027;&#35201;&#29992;&#26469;&#30830;&#23450;&#20351;&#29992;&#21738;&#20123;&#36807;&#28388;&#26041;&#27861;&#10;&#9500;&#9472;&#9472; exceptions.py           &#27809;&#21861;&#29992;&#10;&#9500;&#9472;&#9472; globbing_filter.py      &#23601;&#19968;&#20010;fnmatch&#10;&#9500;&#9472;&#9472; memory_profiler.py      &#10;&#9500;&#9472;&#9472; metadata.py&#10;&#9500;&#9472;&#9472; output                  output.py&#26159;&#22522;&#31867;&#65292;&#20854;&#20182;&#20960;&#20010;&#26159;&#20855;&#20307;&#36755;&#20986;&#26041;&#24335;&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; __init__.py&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; gephi.py&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; graphviz.py&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; output.py&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; pickle.py&#10;&#9474;&#160;&#160; &#9492;&#9472;&#9472; ubigraph.py&#10;&#9500;&#9472;&#9472; pycallgraph.py          &#25972;&#21512;config&#21644;output&#10;&#9500;&#9472;&#9472; tracer.py               &#26680;&#24515;&#25991;&#20214;(&#35843;&#29992;sys.settrace&#30340;&#22320;&#26041;)&#10;&#9492;&#9472;&#9472; util.py</span><br></pre></td></tr></table></figure>
<h3 id="获取函数被哪些函数调用"><a href="#获取函数被哪些函数调用" class="headerlink" title="获取函数被哪些函数调用"></a>获取函数被哪些函数调用</h3><p>查看下面的相关资料。有这样一段代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    g()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> traceback.format_stack():</span><br><span class="line">        print(line.strip())</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prints:</span></span><br><span class="line"><span class="comment"># File "so-stack.py", line 10, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     f()</span></span><br><span class="line"><span class="comment"># File "so-stack.py", line 4, in f</span></span><br><span class="line"><span class="comment">#     g()</span></span><br><span class="line"><span class="comment"># File "so-stack.py", line 7, in g</span></span><br><span class="line"><span class="comment">#     for line in traceback.format_stack():</span></span><br></pre></td></tr></table></figure><br>当f调用g的时候。在g里面有调用了traceback.format_stack，它显示了当调用函数g的时候的调用路径。实现其实是比较简单的嘛。当调用g的时候，它在栈顶。那么只需要不断的调用frame.f_back就能得到上一个栈，就可以得到以上信息。可以看出它得到的是函数被调用的信息。假如函数g调用了很多底层函数，此时我需要进行一些patch hook，那么要得到是函数g调用了哪些底层函数！这种方法就没用了。好在python提供了sys.settrace</p>
<h3 id="sys-settrace基本介绍"><a href="#sys-settrace基本介绍" class="headerlink" title="sys.settrace基本介绍"></a>sys.settrace基本介绍</h3><p>首先得对python运行的基本概念有个了解，函数的调用是一种栈结构。当函数被调用(触发call事件)的时候当前帧入栈，当函数执行完毕返回(触发return事件)的时候栈顶的帧出栈。sys.settrace就是对这些事件的hook。看下面这段代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(frame, event, args,record=[])</span>:</span></span><br><span class="line">    print(frame.f_lineno, frame.f_code.co_filename, event)</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'call'</span>:</span><br><span class="line">        record.append(frame)</span><br><span class="line">    <span class="keyword">elif</span> event == <span class="string">'return'</span>:</span><br><span class="line">        pre_frame = record.pop()</span><br><span class="line">        print(pre_frame <span class="keyword">is</span> frame)</span><br><span class="line">    <span class="keyword">return</span> trace</span><br><span class="line">sys.settrace(trace)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="number">1</span> / i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 11 /Users/ficapy/Dropbox/source_read/py3/settrace.py call</span></span><br><span class="line"><span class="comment"># 12 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 13 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 14 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 14 /Users/ficapy/Dropbox/source_read/py3/settrace.py exception</span></span><br><span class="line"><span class="comment"># 15 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 16 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 12 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 13 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 14 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 12 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 12 /Users/ficapy/Dropbox/source_read/py3/settrace.py return</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure><br>有几点需要注意的:</p>
<ol>
<li>trace函数最后记得返回自身</li>
<li>不需要考虑多线程问题，因为sys.settrace只对主线程有效(多线程是threading.settrace，多进程没试过)</li>
<li>还是要废话一句，发生return的时候frame一定是最后一个call的frame。这也是pycallgraph的运行的基本条件。</li>
<li>虽然trace有7个事件。可是对于我们绘制调用图call、return就够了.</li>
</ol>
<h3 id="pycallgraph原理版本"><a href="#pycallgraph原理版本" class="headerlink" title="pycallgraph原理版本"></a>pycallgraph原理版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">call_dict = defaultdict(<span class="keyword">lambda</span>: defaultdict(int))</span><br><span class="line">frame_stack = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(frame, event, args)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'call'</span>:</span><br><span class="line">        frame_stack.append(frame)</span><br><span class="line">        call_dict[frame.f_back][frame] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'return'</span>:</span><br><span class="line">        <span class="keyword">if</span> frame <span class="keyword">is</span> frame_stack[-<span class="number">1</span>]:</span><br><span class="line">            frame_stack.pop()</span><br><span class="line">    <span class="keyword">return</span> trace</span><br><span class="line"></span><br><span class="line">sys.settrace(trace)</span><br><span class="line">requests.get(<span class="string">'http://www.z.cn'</span>)</span><br><span class="line">sys.settrace(<span class="keyword">None</span>)</span><br><span class="line">pprint(call_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># defaultdict(&lt;function &lt;lambda&gt; at 0x10f282950&gt;,</span></span><br><span class="line"><span class="comment">#             &#123;&lt;frame object at 0x10f199448&gt;: defaultdict(&lt;class 'int'&gt;,</span></span><br><span class="line"><span class="comment">#                                                         &#123;&lt;frame object at 0x10f303848&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                          &lt;frame object at 0x10f4f93d8&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                          &lt;frame object at 0x10f985980&gt;: 1&#125;),</span></span><br><span class="line"><span class="comment">#                                                         :</span></span><br><span class="line"><span class="comment">#                                                         :</span></span><br><span class="line"><span class="comment">#                                                         :</span></span><br><span class="line"><span class="comment">#              &lt;frame object at 0x7fa6630a2018&gt;: defaultdict(&lt;class 'int'&gt;,</span></span><br><span class="line"><span class="comment">#                                                            &#123;&lt;frame object at 0x10fd1b8b8&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x10fd2a9d0&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x10fd2f908&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x10fd32570&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x10fd3fac8&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x7fa662093cc8&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x7fa6621ddc98&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x7fa6621e0468&gt;: 1&#125;)&#125;)</span></span><br></pre></td></tr></table></figure>
<p>在每个函数调用的时候，将当前栈和上一个栈关联起来。所有的数据汇总就得到了requests.get的调用关系图。然后就可以兴奋的去用graphviz生成图片~(≧▽≦)/~啦啦啦，直接这样大概就生成了类似下面的图片<br><img src="https://ws2.sinaimg.cn/large/a25f7e36gw1f62u6liqvqj21kw0awdjr.jpg" alt="confusion_requests"><br>看起来很炫酷，其实嘛用没有，几百个元素线条一大堆，根本突出不了重点。<strong><code>所以收集数据是很容易的，最重要的是过滤数据，重点突出自己需要的数据</code></strong>这部分应该也是pycallgraph的重点要处理的部分(处理的并不好)。</p>
<h3 id="过滤不需要关注的函数"><a href="#过滤不需要关注的函数" class="headerlink" title="过滤不需要关注的函数"></a>过滤不需要关注的函数</h3><p>比如一个函数我们不需要关注。那么当call事件的时候我们只需要不把它加入到call_dict中。同时将当前栈长度设置为最大长度。那么该函数和被该函数调用的函数都不会被我们记录。pycallgraph的做法是:不加入到call_dict，只是对frame_stack列表加入一个空值。return事件也只是简单的pop移出(这样造成的结果就是该函数不被记录，可是该被该函数调用的其他函数只要不被规则过滤就会被记录)<br>通常过滤的条件会有:</p>
<ol>
<li>内置模块</li>
<li>私有函数</li>
<li>比如一些库有compat.py、datastructers.py、exceptions.py、utils.py这些模块常会被引用。可是对了解整个过程并没有什么帮助。反而会导致生成的图很混乱</li>
<li>某些库虽然被引用太多次也该被删除<br>总之就是根据需要关注的地方写过滤规则，生成合适的图~~<br>比如这样。。。。requests.get的<br><img src="https://ficapy.b0.upaiyun.com/blogimg/requests_get.png" alt="requests_get"><br>注意到这里有组(根据单个模块分)，实现的方式也很简单。可以查看我写的精简版的pycallgraph.<a href="https://gist.github.com/ficapy/a2601d44b1492c228732178e1bb3eb5e">https://gist.github.com/ficapy/a2601d44b1492c228732178e1bb3eb5e</a></li>
</ol>
<h3 id="多线程版"><a href="#多线程版" class="headerlink" title="多线程版"></a>多线程版</h3><p>因为目前没有用来分析多线程程序，所以只是大概了解了一下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(frame, event, args,record=[])</span>:</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'call'</span>:</span><br><span class="line">        record.append(frame)</span><br><span class="line">    <span class="keyword">elif</span> event == <span class="string">'return'</span>:</span><br><span class="line">        pre_frame = record.pop()</span><br><span class="line">        print(pre_frame <span class="keyword">is</span> frame)</span><br><span class="line">    <span class="keyword">return</span> trace</span><br><span class="line">threading.settrace(trace)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    threading.Thread(target=main).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure><br>可以看到稍有区别，因为它有多个栈，所以无法像单个那样用一个列表就添加、取出就能搞定。可能以后有需要我会添加上线程支持</p>
<h3 id="pycallgraph缺陷"><a href="#pycallgraph缺陷" class="headerlink" title="pycallgraph缺陷"></a>pycallgraph缺陷</h3><ol>
<li>更新缓慢，master版本是3年前的！文档也是</li>
<li>设置项有threaded.搞的是线程安全！sys.settrace在主线程是没有线程问题。我都没有想明白写线程这段是干啥子用的</li>
<li>没有突出过滤的重要性</li>
</ol>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://docs.python.org/3/library/sys.html#sys.settrace">官网sys.settrace</a><br><a href="http://tech.uc.cn/?p=1932">python程序的执行原理</a><br><a href="https://www.youtube.com/watch?v=YIhGbFW985c">PYCON-Dmitry Trofimov - Python Debugger Uncovered</a><br><a href="http://stackoverflow.com/questions/1156023/print-current-call-stack-from-a-method-in-python-code">Print current call stack from a method in Python code</a><br><a href="https://segmentfault.com/a/1190000000356018">常用的python调试工具</a><br><a href="http://www.jianshu.com/p/e44885a777f0">graphviz dot语言学习笔记</a><br><a href="https://github.com/ionelmc/python-hunter">Github_python-hunter</a><br><a href="https://github.com/alonho/pytrace">Github_pytrace</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用来生成函数调用图，这个工具可能名气比较大。因为看介绍就能看到好像可以生成比较帅气的图像。从源码层面看。其实这个工具是相当简单的，就是使用了sys.settrace接口,该接口常用于debug、profile(本文环境python3.5.1)。&lt;/p&gt;
    
    </summary>
    
      <category term="源码解析" scheme="https://www.zoulei.net/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="python" scheme="https://www.zoulei.net/tags/python/"/>
    
  </entry>
  
</feed>
